{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"puntgun - a configurable automation command line tool for Twitter # 1 2 3 4 5 ____ _ ____ ,___|____\\____________|_|____/____|____________________ |___|_|_)_|_|_|_|_'__\\|___|_|_|___|_|_|_|_'__\\__[____] \"\"-,___..--===== | __/| |_| | | | | |_ | |_| | |_| | | | | \\\\_____/ \"\" | |_| \\__,_|_| |_|\\__| \\____|\\__,_|_| |_| [ ))\"---------..__| Warning The project is still not in a state that I'm happy with (almost there!), the tool is working, there are just too few rules available. You can use this tool to do some boring Twitter account management (such as automatically select and block users from a source like a tweet's likes, your follower...), then you can free up your time for other things. This tool was originally conceived as a configurable automatic Twitter account blocker. What could be a better name for it than the Punt Gun , a special hunting weapon used to kill a large number of waterfowl in one shot. But that type of gun is a huge threat to the natural environment, and fortunately this tool only inherits the meaning of its origin, even to the benefit of the platform environment (or at least to its users). Installation # This tool needs to be installed with the Python application management tool, no separate executable file is distributed, sorry for the inconvenience. The most convenient way to install (and update in the future) this tool is with the help of pipx , which is a handy Python application management tool. Install it first, then run: 1 pipx install puntgun Or your can install this tool via pip which is installed with Python. This tool requires Python version 3.10 or above. Install Python if you haven't installed or your Python version not meet the required, then run: 1 python -m pip install -U puntgun Usage # For users unfamiliar with the command line interface, this tool is a cross-platform command line tool, which means you need to use it in your Windows Command-line shell or Apple Mac Terminal or any other terminal. First you need a \"Twitter Dev OAuth App API\" to enable the tool, with this we can request the developer APIs provided by Twitter. Run the command below to let the tool interactively guide you register one on Twitter platform for free. For more information, read documentation about available commands . 1 puntgun gen secrets Then you need a Plan Configuration file to instruct what the tool will do for you, run the command below to generate an example file. For more information about plan configuration, read the documentation . 1 puntgun gen example Now you can start the tool with your plan file with: 1 puntgun fire If the tool doesn't exit quickly due to configuration errors (with red error logs printed pointing out what's wrong), you can leave the terminal (window) open and move on to other things. The tool will generate a report file (and log file) during runtime, which you can view later to see what happened. For more information on usage, see the documentation website . Technical details you may want to know # How it works # Essentially we make the tool a third-party application that can access the Twitter platform by registering a credential (a pair of secret token) with your Twitter account and then using your Twitter account to authorize this tool (the credential you registered from Twitter, in fact) to operate your account (for blocking users, etc.). Limitation of the Twitter Developer API # First, this tool's performance is depending on the complexity of plan configuration you set which you can control. And what you can't control is that your total API query volume is limited by Twitter, meanwhile the API have different rate limits with different permissions on different endpoints. These limits can sometimes be very impactful on execution speed, such as only fifty block API query is allowed for every fifteen minutes. What's more, you can only search for last 7 days tweets (using \"search/recent\" API) with Essential Twitter API access, and query string length is limited up to 512. Details about secrets encryption and usage # Currently, we use the RSA4096 with the cryptographic library Cryptography for processing secrets to prevent them being saved into configuration file in plaintext format. For implementation details, check this source code file . For Cryptography's security limitation, check this documentation . When the tool is running, the secrets will stay inside a client object of the Twitter API client library Tweepy , and it seems that they are stored as plaintext string . As it can't be garbage collected while we're invoking this client instance all the time when running, I guess we can't prevent secrets from a memory dump attack or something similar. License # This project is open sourced under MIT license .","title":"Home"},{"location":"#puntgun-a-configurable-automation-command-line-tool-for-twitter","text":"1 2 3 4 5 ____ _ ____ ,___|____\\____________|_|____/____|____________________ |___|_|_)_|_|_|_|_'__\\|___|_|_|___|_|_|_|_'__\\__[____] \"\"-,___..--===== | __/| |_| | | | | |_ | |_| | |_| | | | | \\\\_____/ \"\" | |_| \\__,_|_| |_|\\__| \\____|\\__,_|_| |_| [ ))\"---------..__| Warning The project is still not in a state that I'm happy with (almost there!), the tool is working, there are just too few rules available. You can use this tool to do some boring Twitter account management (such as automatically select and block users from a source like a tweet's likes, your follower...), then you can free up your time for other things. This tool was originally conceived as a configurable automatic Twitter account blocker. What could be a better name for it than the Punt Gun , a special hunting weapon used to kill a large number of waterfowl in one shot. But that type of gun is a huge threat to the natural environment, and fortunately this tool only inherits the meaning of its origin, even to the benefit of the platform environment (or at least to its users).","title":"puntgun - a configurable automation command line tool for Twitter"},{"location":"#installation","text":"This tool needs to be installed with the Python application management tool, no separate executable file is distributed, sorry for the inconvenience. The most convenient way to install (and update in the future) this tool is with the help of pipx , which is a handy Python application management tool. Install it first, then run: 1 pipx install puntgun Or your can install this tool via pip which is installed with Python. This tool requires Python version 3.10 or above. Install Python if you haven't installed or your Python version not meet the required, then run: 1 python -m pip install -U puntgun","title":"Installation"},{"location":"#usage","text":"For users unfamiliar with the command line interface, this tool is a cross-platform command line tool, which means you need to use it in your Windows Command-line shell or Apple Mac Terminal or any other terminal. First you need a \"Twitter Dev OAuth App API\" to enable the tool, with this we can request the developer APIs provided by Twitter. Run the command below to let the tool interactively guide you register one on Twitter platform for free. For more information, read documentation about available commands . 1 puntgun gen secrets Then you need a Plan Configuration file to instruct what the tool will do for you, run the command below to generate an example file. For more information about plan configuration, read the documentation . 1 puntgun gen example Now you can start the tool with your plan file with: 1 puntgun fire If the tool doesn't exit quickly due to configuration errors (with red error logs printed pointing out what's wrong), you can leave the terminal (window) open and move on to other things. The tool will generate a report file (and log file) during runtime, which you can view later to see what happened. For more information on usage, see the documentation website .","title":"Usage"},{"location":"#technical-details-you-may-want-to-know","text":"","title":"Technical details you may want to know"},{"location":"#how-it-works","text":"Essentially we make the tool a third-party application that can access the Twitter platform by registering a credential (a pair of secret token) with your Twitter account and then using your Twitter account to authorize this tool (the credential you registered from Twitter, in fact) to operate your account (for blocking users, etc.).","title":"How it works"},{"location":"#limitation-of-the-twitter-developer-api","text":"First, this tool's performance is depending on the complexity of plan configuration you set which you can control. And what you can't control is that your total API query volume is limited by Twitter, meanwhile the API have different rate limits with different permissions on different endpoints. These limits can sometimes be very impactful on execution speed, such as only fifty block API query is allowed for every fifteen minutes. What's more, you can only search for last 7 days tweets (using \"search/recent\" API) with Essential Twitter API access, and query string length is limited up to 512.","title":"Limitation of the Twitter Developer API"},{"location":"#details-about-secrets-encryption-and-usage","text":"Currently, we use the RSA4096 with the cryptographic library Cryptography for processing secrets to prevent them being saved into configuration file in plaintext format. For implementation details, check this source code file . For Cryptography's security limitation, check this documentation . When the tool is running, the secrets will stay inside a client object of the Twitter API client library Tweepy , and it seems that they are stored as plaintext string . As it can't be garbage collected while we're invoking this client instance all the time when running, I guess we can't prevent secrets from a memory dump attack or something similar.","title":"Details about secrets encryption and usage"},{"location":"#license","text":"This project is open sourced under MIT license .","title":"License"},{"location":"old-config-manual/","text":"Configuration Manual # Configuration file is written in YAML format. Your can refer official documentation for the syntax. For character escaping content, read this part . Index # Script Behavior Settings manually_confirm Action Rules User Selecting Rule who id_are username_are are_my_follower hit_search_results_of agree_with_tweet Filter Rule search user-* user_created user_texts_match user_follower user_following user_foer_foing_ratio user_tweet_count user_recent_speaking_ratio last_active_time Let_me_check Rule user_info recent_tweets recent_replies recent_likes Rule Set all_of any_of weight_of Reusable Mechanism Script Behavior Settings # All the script behavior settings should be put directly under the root of configuration file. manually_confirm # field value possible true false default if absent false 1 manually_confirm : true Decide if you want to let the script executes blocking action automatically when block/mute decision of one user is ready, or confirm it manually by interacting with terminal. Note that the rate limit of block/mute API is 50 requests per 15 minutes , pretty slow. So do it automatically is recommended. There are some rules will override this setting and force user to confirm manually on the terminal. Action # Currently, there are only one action: block. One action can have a list of User Selecting Rule s, represent multiple groups of target users. Block API rate of limit is 50 requests per 15 minutes . 1 2 3 4 5 6 7 block : - users : who : id_are : [ \"12345678\" , \"87654321\" ] - users : who : username_are : [ \"Twitter\" , \"TwitterAPI\" ] Rule Description # The rules work together like: An Action can have multiple User Selecting Rule s, we've mentioned above. A User Selecting Rule specifies a group of users, it's the start of a processing stream. An optional Rule Set contains multiple rigid Filter Rule s and nested Rule Set , driven by relationships between various data (e.g. follower_less_than: {a number} ). One User Selecting Rule can have 0~1 Rule Set as further filter chain. User Selecting Rule 's result user group is passed through these filters, and users who satisfy the conditions will be blocked/muted. An optional Let_me_check Rule allows you to check for users who didn't trigger the filter rule by your self and manually decide their fate. Here this is a sample complete example: 1 2 3 4 5 6 7 block : - users : who : id_are : [ \"12345678\" , \"87654321\" ] all_of : - follower_less_than : 10 let_me_check : [ \"user_info\" ] User Selecting Rule # This type of rules can be put directly under the action field, each of which can specify a group of potential target user with who field. If there is no Rule Set or Let_me_check Rule under one \"users\" rule, perform the action on all users in the who 's result group. 1 2 3 4 5 6 7 block : - users : who : # required id_are : [ \"12345678\" , \"87654321\" ] all_of : # optional - follower_less_than : 10 let_me_check : [ \"user_info\" ] # optional who # field value possible id_are username_are are_my_follower hit_search_results_of agree_with_tweet id_are a list of user id username_are a list of username are_my_follower inner fields hit_search_results_of a list of search rules agree_with_tweet inner fields This is a required field under User Selecting Rule , indicating user selection metric type and value. id_are # Specify a list of user id. Somehow you get them from another automatic_twitter_process source, because these users' id are not displayed by the client normally, although this field is positioned like the primary key in every user API queries. If you want to get one user's id manually, maybe you can get it in Twitter Web Client 's XHRs via browser dev tools? BTW I found a website where you can query the Twitter user id with username e.g. \"@Twitter\". But if you insist to manually type them into configuration file, I suggest you to straightly view and block these users via a client, that's faster (smartphone client is more convenient than web client on doing this job). 1 2 3 users : who : id_are : [ \"12345678\" , \"87654321\" ] username_are # Specify a list of username (also called \" handle\"). It's easy to get it, just remove the first \"@\" symbol. But same as above, manually typing down them is awkward, not recommended. 1 2 3 users : who : username_are : [ \"Twitter\" , \"TwitterAPI\" ] are_my_follower # field value possible last last the last N number of (newest) followers Select users from your followers. Currently, there are only one config: specify the number of newcomers. (I'm sad that I can't give you some configs like \"followed_me_after: time\", because I haven't found a way to get this information from the API.) 1 2 3 4 users : who : are_my_follower : last : 100 hit_search_results_of # Specify users that appear in (any of) a set of tweet search results. Check search rule for more details. 1 2 3 4 5 users : who : hit_search_results_of : - search_query : 'tweet_query_string-1' - search_query : 'tweet_query_string-2' agree_with_tweet # field value possible id , or a search rule id the tweet id, string search inner fields Specify users who liked or retweeted (except \"Quote Tweet\") one specific tweet. There are more than one way to indicate that tweet, the script will choose the first . Please note that the \"like\"/\"retweet\" action itself does not just mean that user agrees with the content of the tweet. So be careful when using this rule, or consider manually checking with Let_me_check Rule . The tweet id can be found in that tweet's share link, for example, in https://twitter.com/{username}/status/{12345678} the tweet id is \"12345678\". These days the length of tweet id is 64-bit (8 bytes, a long type) accounting to official documentation. If you choose the search rule: Please try it manually on client before running script, make sure only that one tweet hit your query criteria. The script will blindly pick the first one from query response. And please make sure the script can search that tweet (7-days_time_limit etc.). If the script can't find it via searching, you can try to find that tweet's id, and use the id field instead. 1 2 3 4 5 users : who : agree_with_tweet : id : \"12345678\" # search_query: 'tweet_query_string' Filter Rule # This type of rules can't exist independently, and must be put under a rule set . Though they can't indicate user group from nothing, but they can help to further specify the behavior of the target user, helping the script to make the final decision. 1 2 3 4 5 6 7 8 9 users : who : id_are : [ \"12345678\" , \"87654321\" ] # this is a option set any_of : # these two are filter rules - search_query : 'tweet_query_string-1' - user_created : after : '2022-01-01' search # field value possible name count query name optional, custom name of this search rule, string count optional, number of tweets to be searched, integer, default 100 query required, a tweet query, string basic # This rule is basically maps the Twitter Tweet Search API . According to official documentation, the query length is limited up to 512 characters, and can only search the last 7 days of tweets with Essential Twitter API access. This rule is powerful but easily being misused, due to its fuzzy search feature, make sure you have read advices below and knowing clearly what tweet content will hit your searching query. About count : There is no max number limit of one query can get, but sending one API query can get 100 at most, so calculate the number of query you need to send by your own. Check this guide for how to write a search query string. For character escaping concern when writing query, read this documentation . (It's better to test it before running the script.) If search query result is not empty, triggered. more # You can save your api query volume by integrating search query rules to minimum number. The rate of limit of tweet searching API is 180 requests per 15 minutes with Essential Twitter API access. When used as a further filter rule (not under who field), the script will generate a prefix from:{user_id} followed by this query string, to specify searching only that user's tweets, which also means you should leave about 25 characters space from 512 length limit for the prefix appending. I'd like to tell you more about how to write a proper query string: Be careful to construct the query string, example 1 below may wrongly hit something like \"I like coffee, and I don't hate cats, I love them\" which is not what you want. My suggestion? Use long accurate (quoted by double quotation mark) query keyword, like example 2. Or use highly emotive and offensive keywords, which means you hate the user who just use these words to express themselves. like example 3. 1 2 3 4 5 # example 1, detailed rule - search : name : hate coffee or cats query : '\"hate\" \"coffee\" OR \"cats\"' count : 100 And... here is a simple format of search rule -- search_query , you just need to specify the query string, the count is set to 100 by default. 1 2 3 4 5 # example 2, long accurate keyword with quotation mark - search_query : '\"\u6536\u7559\u65e0\u5bb6\u53ef\u5f52\u7684\u4e4c\u514b\u5170\u5c0f\u59d0\u59d0\"' # example 3, highly emotive and offensive keyword - search_query : '\"son of a b*tch\"' user_something # These rules show how to use user information relative metrics, they have a common prefix: user- . user_created # field value possible before after before time, string after time, string within_days day number, number The time format of before and after are \"date\" yyyy_MM_dd or \"date time\" yyyy_MM_dd HH:mm:ss , when using former format, the time part will be extended as 00:00:00 . They can be used together or separately, but be careful of the validity of two times relation. For convenience of scheduled repeatable task, the whitin_days field can be used to specify a time range from now, to specify newly created accounts. It can't be used with before or after fields. Times your configured are considered at UTC (+0) timezone. 1 2 3 4 5 6 - user_created : after : \"2019-01-01 00:00:00\" before : \"2020-01-01\" - user_created : within_days : 30 Shorten version: 1 2 3 - user_created_after : \"2019-01-01\" - user_created_within_days : 30 user_texts_match # field value possible a regular expression Another rule that can easily be misused , same as search rule, due to its highly possible wrongly triggered feature, be careful when using it. There are three part of text directly bind (can be queried along with Twitter user info query API) with user: user's name (the name you see aside the avatar) user's description (also called profile) pinned tweet's text This rule independently performs python regular expression match on each of these texts. If any part of them matches the given expression, the rule triggered. Simple, yet powerful. The script will not automatically anchor the expression with ^$ . You can test your regular expression on this website . Also, be careful of character escaping concern, for both yaml context (quote the expression with single/double quotation mark) and python regex context (with backslash character ). 1 2 3 4 5 6 # note that if you quote the expression in yaml, # you should use double backslash for python regex escaping user_texts_match : '[\\\\u1F100-\\\\u1F1E5]' # it's same as above without quote and double backslash # user_texts_match: [\\u1F100-\\u1F1E5] user_follower # field value possible less_than more_than less_than integer more_than integer Two fields can be used together or separately. Edge case (equal) result in False. 1 2 3 - user_follower : more_than : 100 less_than : 1000 Shorten version: 1 - user_follower_less_than : 10 user_following # field value possible less_than more_than less_than integer more_than integer Two fields can be used together or separately. Edge case (equal) result in False. 1 2 3 - user_following : more_than : 100 less_than : 1000 Shorten version: 1 - user_following_more_than : 10 user_foer_foing_ratio # field value possible less_than more_than less_than float more_than float Two fields can be used together or separately. Edge case (equal) result in False. 1 2 3 - user_foer_foing_ratio : more_than : 0.1 # 1 follower / 10 following less_than : 10.0 # 10 follower / 1 following Shorten version: 1 2 # 1 follower / 100 following, this ratio tells something - user_foer_foing_ratio_less_than : 0.01 user_tweet_count # field value possible less_than more_than less_than number more_than number Two fields can be used together or separately. Edge case (equal) result in False. There is a simple format: user_tweet_count_less_than . Just notice that this count includes both post and retweet. 1 2 3 4 5 - user_tweet_count : more_than : 100 less_than : 1000 - user_tweet_count_less_than : 10 user_recent_speaking_ratio # field value possible recent less_than more_than recent number of recent tweets in count, default 100 less_than number, (0,1.0] more_than number, (0,1.0] less_than and more_than can be used together or separately. recent is optional, default 100 when absent. The definition of \"speaking\" is either a post or reply operation, two operations that user must type something before sending out. The ratio is calculated as: (reply + post) / (reply + post + retweet) The higher the ratio, the more user intend to show his/her own thought, instead of silently retweeting others thought. 1 2 3 4 - user_recent_speaking_ratio : count : 100 more_than : 0.2 # at least 20% of recent tweets are post less_than : 0.9 # not more 90% of recent tweets are post last_active_time # field value possible ignore before after within_days ignore number of ignored activity trace, default 0 before time, string after time, string within_days day number, number This rule will search for the last activity traces of the user, the definition of activity trace including: post, reply, like, retweet. The time format of before and after are \"date\" yyyy_MM_dd or \"date time\" yyyy_MM_dd HH:mm:ss , when using former format, the time part will be extended as 00:00:00 . They can be used together or separately. The whitin_days field can be used to specify a time range from now. It can't be used with before or after fields. You can set the ignore field to judge the 2nd ( ignore=1 ), 3rd ( ignore=2 )... last active time. It's useful when you already know the last activity of user, for example you specified the target user group by agree_with_tweet rule, so \"agree with that fresh tweet\" will be at least one of the last activity of the user. 1 2 3 last_active_time : ignore : 1 within_days : 7 Let_me_check Rule # field value possible user_info , recent_tweets , recent_replies , recent_likes user_info the value doesn't matter recent_tweets number of recent tweets recent_replies inner fields recent_likes number of recent liked tweets This rule can only be put directly under a User Selecting Rule . The human brain is excellent at natural language processing work, and this special rule helps scripts make decisions with the help of your subjective judgment ... In other words, the script first helps you (via Filter Rule s) automatically select users who meet the filter rules conditions, and then YOU make the final decision on the remaining users who do not trigger the filter rules, and make the final decision on them. The different fields determine what information the script will print to the terminal for your judgment. This rule can override the manually_confirm settings, and force you to integrate with the script. 1 2 3 4 5 6 7 8 9 10 users : who : id_are : [ \"123456789\" , \"987654321\" ] let_me_check : user_info : true recent_tweets : 3 recent_replies : count : 3 with_origin_tweet : true recent_likes : 3 user_info # Provides information about the user, including: user's name (besides the avatar), screen name (behinds an \"@\"), following, follower count profile, pinned tweet text This field's value can be anything because the script will ignore it. (I wish I can give you a which_your_following_is_following_this_user option, (you can see that on various Twitter Clients when you're viewing a user's profile), which provides you a measure of trust of acquaintances. But for making sense of it, the script has to send a large number of request on every target user, which is not a good choice at a time when the Twitter Dev API has rate_limitation.) 1 2 let_me_check : user_info : true recent_tweets # field value possible number of recent tweets Provide the recent tweets of the user, including post and retweet, if the retweet is a quote tweet, the original quoted tweet will be printed together. 1 2 let_me_check : recent_tweets : 3 recent_replies # field value possible count with_origin_tweet count number of recent replies, default 3 with_origin_tweet whether to print the origin tweet text, true or false , default false Provide the recent replies of the user, optionally with the origin tweet text. Since a reply is necessarily written by the user_self, expressing an opinion about the content of some else tweet, it provides a clearer picture of the user's thoughts. 1 2 3 let_me_check : recent_replies : with_origin_tweet : true recent_likes # field value possible number of recent liked tweets Provide the recent liked tweets of the user. Almost every user will like tweets, including those that don't express their thoughts much, and this is the easiest interaction action. We can label users by looking at what content they liked, which is undoubtedly reckless, because one can provide quality content while unabashedly showing a love for NSFW or other bad content, and the \"like\" action itself does not just mean that user agrees with the content of the tweet. But... it's still a practical way to decide whether a user needs to be blocked, it's up to you after all. 1 2 let_me_check : recent_likes : 3 Rule Set # field value possible a name , and other Filter Rule s or nested Rule Set s name optional, the custom name of the rule set An Rule Set contains a list of Filter Rule s and nested Rule Set s. Like the who field, a rule set can be put under a User Selecting Rule , and one User Selecting Rule can have 0~1 rule set as further filter chain. You can optionally give a rule set a custom name with name field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 users : who : id_are : [ \"123456789\" , \"987654321\" ] all_of : - name : \"new account\" # a filter option - user_created : after : \"2022-01-01\" # a nested option set - any_of : - name : \"not speak much\" - user_foer_foing_ratio_less_than : 0.1 - user_tweet_count_less_than : 10 - user_recent_speaking_ratio_less_than : 0.05 all_of # AND logic rule set, all of under rules triggered, this set triggered. I don't think I need to introduce it more, do I? any_of # OR logic rule set, any of under rules triggered, this set triggered. weight_of # field value possible required goal , optional name , and multiple condition name the custom name of the rule set goal when to trigger the rule, number condition contains one weight and one Filter Rule or nested Rule Set As you can see in the example, filter rules and nested rule sets need to be wrapped into a condition , pairing with a weight to indicate the weight of this rule. The value of goal , weight field can be any positive integer. When accumulated triggered rules' weights not less than this value, the weight_of rule triggered. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 weight_of : - goal : 2 - condition : - weight : 2 - user_foer_foing_ratio_less_than : 0.1 - condition : - weight : 1 - user_tweet_count_less_than : 10 - condition : - weight : 1 - any_of : - user_recent_speaking_ratio_less_than : 0.05 - last_active_time : ignore : 1 before : \"2022-01-01\" Reusable Mechanism # There must be a reusable mechanism in one configuration system to reduce redundancy, here it is. Fields defined under fragments with a custom name as referring key can be repeatedly referenced with refer . One fragment can contain several fields. You may notice that fields can be arranged as both field (e.g. \"numeric_fields\") or list (e.g. \"search_rules\") format, and this format will remain unchanged after the script parsing refer field, so if you wrongly referred a list_format fragment under a field_format_required field, the configuration file parser will complain about that and quit. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 block : - users : who : hit_search_results_of : # equal to: # - search_query: 'tweet_query_string-1' # - search_query: 'tweet_query_string-2' - refer : search_rules # can still add more fields - search_query : 'tweet_query_string-3' any_of : - user_follower : # equal to: # more_than: 10 # less_than: 100 refer : numeric_fields fragments : - search_rules : - search_query : 'tweet_query_string-1' - search_query : 'tweet_query_string-2' - numeric_fields : more_than : 10 less_than : 1000","title":"Configuration Manual"},{"location":"old-config-manual/#configuration-manual","text":"Configuration file is written in YAML format. Your can refer official documentation for the syntax. For character escaping content, read this part .","title":"Configuration Manual"},{"location":"old-config-manual/#index","text":"Script Behavior Settings manually_confirm Action Rules User Selecting Rule who id_are username_are are_my_follower hit_search_results_of agree_with_tweet Filter Rule search user-* user_created user_texts_match user_follower user_following user_foer_foing_ratio user_tweet_count user_recent_speaking_ratio last_active_time Let_me_check Rule user_info recent_tweets recent_replies recent_likes Rule Set all_of any_of weight_of Reusable Mechanism","title":"Index"},{"location":"old-config-manual/#script-behavior-settings","text":"All the script behavior settings should be put directly under the root of configuration file.","title":"Script Behavior Settings"},{"location":"old-config-manual/#manually_confirm","text":"field value possible true false default if absent false 1 manually_confirm : true Decide if you want to let the script executes blocking action automatically when block/mute decision of one user is ready, or confirm it manually by interacting with terminal. Note that the rate limit of block/mute API is 50 requests per 15 minutes , pretty slow. So do it automatically is recommended. There are some rules will override this setting and force user to confirm manually on the terminal.","title":"manually_confirm"},{"location":"old-config-manual/#action","text":"Currently, there are only one action: block. One action can have a list of User Selecting Rule s, represent multiple groups of target users. Block API rate of limit is 50 requests per 15 minutes . 1 2 3 4 5 6 7 block : - users : who : id_are : [ \"12345678\" , \"87654321\" ] - users : who : username_are : [ \"Twitter\" , \"TwitterAPI\" ]","title":"Action"},{"location":"old-config-manual/#rule-description","text":"The rules work together like: An Action can have multiple User Selecting Rule s, we've mentioned above. A User Selecting Rule specifies a group of users, it's the start of a processing stream. An optional Rule Set contains multiple rigid Filter Rule s and nested Rule Set , driven by relationships between various data (e.g. follower_less_than: {a number} ). One User Selecting Rule can have 0~1 Rule Set as further filter chain. User Selecting Rule 's result user group is passed through these filters, and users who satisfy the conditions will be blocked/muted. An optional Let_me_check Rule allows you to check for users who didn't trigger the filter rule by your self and manually decide their fate. Here this is a sample complete example: 1 2 3 4 5 6 7 block : - users : who : id_are : [ \"12345678\" , \"87654321\" ] all_of : - follower_less_than : 10 let_me_check : [ \"user_info\" ]","title":"Rule Description"},{"location":"old-config-manual/#user-selecting-rule","text":"This type of rules can be put directly under the action field, each of which can specify a group of potential target user with who field. If there is no Rule Set or Let_me_check Rule under one \"users\" rule, perform the action on all users in the who 's result group. 1 2 3 4 5 6 7 block : - users : who : # required id_are : [ \"12345678\" , \"87654321\" ] all_of : # optional - follower_less_than : 10 let_me_check : [ \"user_info\" ] # optional","title":"User Selecting Rule"},{"location":"old-config-manual/#who","text":"field value possible id_are username_are are_my_follower hit_search_results_of agree_with_tweet id_are a list of user id username_are a list of username are_my_follower inner fields hit_search_results_of a list of search rules agree_with_tweet inner fields This is a required field under User Selecting Rule , indicating user selection metric type and value.","title":"who"},{"location":"old-config-manual/#id_are","text":"Specify a list of user id. Somehow you get them from another automatic_twitter_process source, because these users' id are not displayed by the client normally, although this field is positioned like the primary key in every user API queries. If you want to get one user's id manually, maybe you can get it in Twitter Web Client 's XHRs via browser dev tools? BTW I found a website where you can query the Twitter user id with username e.g. \"@Twitter\". But if you insist to manually type them into configuration file, I suggest you to straightly view and block these users via a client, that's faster (smartphone client is more convenient than web client on doing this job). 1 2 3 users : who : id_are : [ \"12345678\" , \"87654321\" ]","title":"id_are"},{"location":"old-config-manual/#username_are","text":"Specify a list of username (also called \" handle\"). It's easy to get it, just remove the first \"@\" symbol. But same as above, manually typing down them is awkward, not recommended. 1 2 3 users : who : username_are : [ \"Twitter\" , \"TwitterAPI\" ]","title":"username_are"},{"location":"old-config-manual/#are_my_follower","text":"field value possible last last the last N number of (newest) followers Select users from your followers. Currently, there are only one config: specify the number of newcomers. (I'm sad that I can't give you some configs like \"followed_me_after: time\", because I haven't found a way to get this information from the API.) 1 2 3 4 users : who : are_my_follower : last : 100","title":"are_my_follower"},{"location":"old-config-manual/#hit_search_results_of","text":"Specify users that appear in (any of) a set of tweet search results. Check search rule for more details. 1 2 3 4 5 users : who : hit_search_results_of : - search_query : 'tweet_query_string-1' - search_query : 'tweet_query_string-2'","title":"hit_search_results_of"},{"location":"old-config-manual/#agree_with_tweet","text":"field value possible id , or a search rule id the tweet id, string search inner fields Specify users who liked or retweeted (except \"Quote Tweet\") one specific tweet. There are more than one way to indicate that tweet, the script will choose the first . Please note that the \"like\"/\"retweet\" action itself does not just mean that user agrees with the content of the tweet. So be careful when using this rule, or consider manually checking with Let_me_check Rule . The tweet id can be found in that tweet's share link, for example, in https://twitter.com/{username}/status/{12345678} the tweet id is \"12345678\". These days the length of tweet id is 64-bit (8 bytes, a long type) accounting to official documentation. If you choose the search rule: Please try it manually on client before running script, make sure only that one tweet hit your query criteria. The script will blindly pick the first one from query response. And please make sure the script can search that tweet (7-days_time_limit etc.). If the script can't find it via searching, you can try to find that tweet's id, and use the id field instead. 1 2 3 4 5 users : who : agree_with_tweet : id : \"12345678\" # search_query: 'tweet_query_string'","title":"agree_with_tweet"},{"location":"old-config-manual/#filter-rule","text":"This type of rules can't exist independently, and must be put under a rule set . Though they can't indicate user group from nothing, but they can help to further specify the behavior of the target user, helping the script to make the final decision. 1 2 3 4 5 6 7 8 9 users : who : id_are : [ \"12345678\" , \"87654321\" ] # this is a option set any_of : # these two are filter rules - search_query : 'tweet_query_string-1' - user_created : after : '2022-01-01'","title":"Filter Rule"},{"location":"old-config-manual/#search","text":"field value possible name count query name optional, custom name of this search rule, string count optional, number of tweets to be searched, integer, default 100 query required, a tweet query, string","title":"search"},{"location":"old-config-manual/#basic","text":"This rule is basically maps the Twitter Tweet Search API . According to official documentation, the query length is limited up to 512 characters, and can only search the last 7 days of tweets with Essential Twitter API access. This rule is powerful but easily being misused, due to its fuzzy search feature, make sure you have read advices below and knowing clearly what tweet content will hit your searching query. About count : There is no max number limit of one query can get, but sending one API query can get 100 at most, so calculate the number of query you need to send by your own. Check this guide for how to write a search query string. For character escaping concern when writing query, read this documentation . (It's better to test it before running the script.) If search query result is not empty, triggered.","title":"basic"},{"location":"old-config-manual/#more","text":"You can save your api query volume by integrating search query rules to minimum number. The rate of limit of tweet searching API is 180 requests per 15 minutes with Essential Twitter API access. When used as a further filter rule (not under who field), the script will generate a prefix from:{user_id} followed by this query string, to specify searching only that user's tweets, which also means you should leave about 25 characters space from 512 length limit for the prefix appending. I'd like to tell you more about how to write a proper query string: Be careful to construct the query string, example 1 below may wrongly hit something like \"I like coffee, and I don't hate cats, I love them\" which is not what you want. My suggestion? Use long accurate (quoted by double quotation mark) query keyword, like example 2. Or use highly emotive and offensive keywords, which means you hate the user who just use these words to express themselves. like example 3. 1 2 3 4 5 # example 1, detailed rule - search : name : hate coffee or cats query : '\"hate\" \"coffee\" OR \"cats\"' count : 100 And... here is a simple format of search rule -- search_query , you just need to specify the query string, the count is set to 100 by default. 1 2 3 4 5 # example 2, long accurate keyword with quotation mark - search_query : '\"\u6536\u7559\u65e0\u5bb6\u53ef\u5f52\u7684\u4e4c\u514b\u5170\u5c0f\u59d0\u59d0\"' # example 3, highly emotive and offensive keyword - search_query : '\"son of a b*tch\"'","title":"more"},{"location":"old-config-manual/#user_something","text":"These rules show how to use user information relative metrics, they have a common prefix: user- .","title":"user_something"},{"location":"old-config-manual/#user_created","text":"field value possible before after before time, string after time, string within_days day number, number The time format of before and after are \"date\" yyyy_MM_dd or \"date time\" yyyy_MM_dd HH:mm:ss , when using former format, the time part will be extended as 00:00:00 . They can be used together or separately, but be careful of the validity of two times relation. For convenience of scheduled repeatable task, the whitin_days field can be used to specify a time range from now, to specify newly created accounts. It can't be used with before or after fields. Times your configured are considered at UTC (+0) timezone. 1 2 3 4 5 6 - user_created : after : \"2019-01-01 00:00:00\" before : \"2020-01-01\" - user_created : within_days : 30 Shorten version: 1 2 3 - user_created_after : \"2019-01-01\" - user_created_within_days : 30","title":"user_created"},{"location":"old-config-manual/#user_texts_match","text":"field value possible a regular expression Another rule that can easily be misused , same as search rule, due to its highly possible wrongly triggered feature, be careful when using it. There are three part of text directly bind (can be queried along with Twitter user info query API) with user: user's name (the name you see aside the avatar) user's description (also called profile) pinned tweet's text This rule independently performs python regular expression match on each of these texts. If any part of them matches the given expression, the rule triggered. Simple, yet powerful. The script will not automatically anchor the expression with ^$ . You can test your regular expression on this website . Also, be careful of character escaping concern, for both yaml context (quote the expression with single/double quotation mark) and python regex context (with backslash character ). 1 2 3 4 5 6 # note that if you quote the expression in yaml, # you should use double backslash for python regex escaping user_texts_match : '[\\\\u1F100-\\\\u1F1E5]' # it's same as above without quote and double backslash # user_texts_match: [\\u1F100-\\u1F1E5]","title":"user_texts_match"},{"location":"old-config-manual/#user_follower","text":"field value possible less_than more_than less_than integer more_than integer Two fields can be used together or separately. Edge case (equal) result in False. 1 2 3 - user_follower : more_than : 100 less_than : 1000 Shorten version: 1 - user_follower_less_than : 10","title":"user_follower"},{"location":"old-config-manual/#user_following","text":"field value possible less_than more_than less_than integer more_than integer Two fields can be used together or separately. Edge case (equal) result in False. 1 2 3 - user_following : more_than : 100 less_than : 1000 Shorten version: 1 - user_following_more_than : 10","title":"user_following"},{"location":"old-config-manual/#user_foer_foing_ratio","text":"field value possible less_than more_than less_than float more_than float Two fields can be used together or separately. Edge case (equal) result in False. 1 2 3 - user_foer_foing_ratio : more_than : 0.1 # 1 follower / 10 following less_than : 10.0 # 10 follower / 1 following Shorten version: 1 2 # 1 follower / 100 following, this ratio tells something - user_foer_foing_ratio_less_than : 0.01","title":"user_foer_foing_ratio"},{"location":"old-config-manual/#user_tweet_count","text":"field value possible less_than more_than less_than number more_than number Two fields can be used together or separately. Edge case (equal) result in False. There is a simple format: user_tweet_count_less_than . Just notice that this count includes both post and retweet. 1 2 3 4 5 - user_tweet_count : more_than : 100 less_than : 1000 - user_tweet_count_less_than : 10","title":"user_tweet_count"},{"location":"old-config-manual/#user_recent_speaking_ratio","text":"field value possible recent less_than more_than recent number of recent tweets in count, default 100 less_than number, (0,1.0] more_than number, (0,1.0] less_than and more_than can be used together or separately. recent is optional, default 100 when absent. The definition of \"speaking\" is either a post or reply operation, two operations that user must type something before sending out. The ratio is calculated as: (reply + post) / (reply + post + retweet) The higher the ratio, the more user intend to show his/her own thought, instead of silently retweeting others thought. 1 2 3 4 - user_recent_speaking_ratio : count : 100 more_than : 0.2 # at least 20% of recent tweets are post less_than : 0.9 # not more 90% of recent tweets are post","title":"user_recent_speaking_ratio"},{"location":"old-config-manual/#last_active_time","text":"field value possible ignore before after within_days ignore number of ignored activity trace, default 0 before time, string after time, string within_days day number, number This rule will search for the last activity traces of the user, the definition of activity trace including: post, reply, like, retweet. The time format of before and after are \"date\" yyyy_MM_dd or \"date time\" yyyy_MM_dd HH:mm:ss , when using former format, the time part will be extended as 00:00:00 . They can be used together or separately. The whitin_days field can be used to specify a time range from now. It can't be used with before or after fields. You can set the ignore field to judge the 2nd ( ignore=1 ), 3rd ( ignore=2 )... last active time. It's useful when you already know the last activity of user, for example you specified the target user group by agree_with_tweet rule, so \"agree with that fresh tweet\" will be at least one of the last activity of the user. 1 2 3 last_active_time : ignore : 1 within_days : 7","title":"last_active_time"},{"location":"old-config-manual/#let_me_check-rule","text":"field value possible user_info , recent_tweets , recent_replies , recent_likes user_info the value doesn't matter recent_tweets number of recent tweets recent_replies inner fields recent_likes number of recent liked tweets This rule can only be put directly under a User Selecting Rule . The human brain is excellent at natural language processing work, and this special rule helps scripts make decisions with the help of your subjective judgment ... In other words, the script first helps you (via Filter Rule s) automatically select users who meet the filter rules conditions, and then YOU make the final decision on the remaining users who do not trigger the filter rules, and make the final decision on them. The different fields determine what information the script will print to the terminal for your judgment. This rule can override the manually_confirm settings, and force you to integrate with the script. 1 2 3 4 5 6 7 8 9 10 users : who : id_are : [ \"123456789\" , \"987654321\" ] let_me_check : user_info : true recent_tweets : 3 recent_replies : count : 3 with_origin_tweet : true recent_likes : 3","title":"Let_me_check Rule"},{"location":"old-config-manual/#user_info","text":"Provides information about the user, including: user's name (besides the avatar), screen name (behinds an \"@\"), following, follower count profile, pinned tweet text This field's value can be anything because the script will ignore it. (I wish I can give you a which_your_following_is_following_this_user option, (you can see that on various Twitter Clients when you're viewing a user's profile), which provides you a measure of trust of acquaintances. But for making sense of it, the script has to send a large number of request on every target user, which is not a good choice at a time when the Twitter Dev API has rate_limitation.) 1 2 let_me_check : user_info : true","title":"user_info"},{"location":"old-config-manual/#recent_tweets","text":"field value possible number of recent tweets Provide the recent tweets of the user, including post and retweet, if the retweet is a quote tweet, the original quoted tweet will be printed together. 1 2 let_me_check : recent_tweets : 3","title":"recent_tweets"},{"location":"old-config-manual/#recent_replies","text":"field value possible count with_origin_tweet count number of recent replies, default 3 with_origin_tweet whether to print the origin tweet text, true or false , default false Provide the recent replies of the user, optionally with the origin tweet text. Since a reply is necessarily written by the user_self, expressing an opinion about the content of some else tweet, it provides a clearer picture of the user's thoughts. 1 2 3 let_me_check : recent_replies : with_origin_tweet : true","title":"recent_replies"},{"location":"old-config-manual/#recent_likes","text":"field value possible number of recent liked tweets Provide the recent liked tweets of the user. Almost every user will like tweets, including those that don't express their thoughts much, and this is the easiest interaction action. We can label users by looking at what content they liked, which is undoubtedly reckless, because one can provide quality content while unabashedly showing a love for NSFW or other bad content, and the \"like\" action itself does not just mean that user agrees with the content of the tweet. But... it's still a practical way to decide whether a user needs to be blocked, it's up to you after all. 1 2 let_me_check : recent_likes : 3","title":"recent_likes"},{"location":"old-config-manual/#rule-set","text":"field value possible a name , and other Filter Rule s or nested Rule Set s name optional, the custom name of the rule set An Rule Set contains a list of Filter Rule s and nested Rule Set s. Like the who field, a rule set can be put under a User Selecting Rule , and one User Selecting Rule can have 0~1 rule set as further filter chain. You can optionally give a rule set a custom name with name field. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 users : who : id_are : [ \"123456789\" , \"987654321\" ] all_of : - name : \"new account\" # a filter option - user_created : after : \"2022-01-01\" # a nested option set - any_of : - name : \"not speak much\" - user_foer_foing_ratio_less_than : 0.1 - user_tweet_count_less_than : 10 - user_recent_speaking_ratio_less_than : 0.05","title":"Rule Set"},{"location":"old-config-manual/#all_of","text":"AND logic rule set, all of under rules triggered, this set triggered. I don't think I need to introduce it more, do I?","title":"all_of"},{"location":"old-config-manual/#any_of","text":"OR logic rule set, any of under rules triggered, this set triggered.","title":"any_of"},{"location":"old-config-manual/#weight_of","text":"field value possible required goal , optional name , and multiple condition name the custom name of the rule set goal when to trigger the rule, number condition contains one weight and one Filter Rule or nested Rule Set As you can see in the example, filter rules and nested rule sets need to be wrapped into a condition , pairing with a weight to indicate the weight of this rule. The value of goal , weight field can be any positive integer. When accumulated triggered rules' weights not less than this value, the weight_of rule triggered. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 weight_of : - goal : 2 - condition : - weight : 2 - user_foer_foing_ratio_less_than : 0.1 - condition : - weight : 1 - user_tweet_count_less_than : 10 - condition : - weight : 1 - any_of : - user_recent_speaking_ratio_less_than : 0.05 - last_active_time : ignore : 1 before : \"2022-01-01\"","title":"weight_of"},{"location":"old-config-manual/#reusable-mechanism","text":"There must be a reusable mechanism in one configuration system to reduce redundancy, here it is. Fields defined under fragments with a custom name as referring key can be repeatedly referenced with refer . One fragment can contain several fields. You may notice that fields can be arranged as both field (e.g. \"numeric_fields\") or list (e.g. \"search_rules\") format, and this format will remain unchanged after the script parsing refer field, so if you wrongly referred a list_format fragment under a field_format_required field, the configuration file parser will complain about that and quit. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 block : - users : who : hit_search_results_of : # equal to: # - search_query: 'tweet_query_string-1' # - search_query: 'tweet_query_string-2' - refer : search_rules # can still add more fields - search_query : 'tweet_query_string-3' any_of : - user_follower : # equal to: # more_than: 10 # less_than: 100 refer : numeric_fields fragments : - search_rules : - search_query : 'tweet_query_string-1' - search_query : 'tweet_query_string-2' - numeric_fields : more_than : 10 less_than : 1000","title":"Reusable Mechanism"},{"location":"configuration/detailed-plan-configuration/","text":"Detailed Plan Configuration # This page contains all details and cautions about plan configuration: which field is required (must be set) in one rule, what value can a field takes... If you are confused about usage of a rule, the answer is most likely written on this page of the documentation. (Can't find what you want? Ask questions to remind us to improve the documentation.) Tool Scope Concepts # Time Type Values # All the time type values user configured for the tool, generated by the tool, are taken at UTC+0 (i.e. Greenwich Mean Time Zone). (But in general you don't need to be too concerned about a few hours' deviation in filter rules setting or so.) There are three available time formats for configuration: 2022-01-01 01:01:01 -> datetime.datetime(2022, 1, 1, 1, 1, 1) 2022-01-01 -> datetime.date(2022, 1, 1) (the time part is 00:00:00 ) 2022-01-01T01:01:01Z -> datetime.datetime(2022, 1, 1, 1, 1, 1) Tips about Searching and Matching # For more information about Twitter search queries, please refer to the official documentation . Both tweet search and regular matching are simple yet powerful rules. They are extremely easy to misuse because they just match characters in text rather than the semantics of the text. For example, let's say you want to select people who hate cats and use hate cats as the keyword, but instead you get a match for I hate cockroach!!! Love cats so much \u2665\u2665\u2665\u2665 . Our advice is to carefully choose words that only your target group will say: Use short phrases that are long enough not to confuse semantics but iconic as keywords, such as campaign slogans, taglines or hashtags. Make keywords contain special words that are so highly emotional or so intensely offensive that people outside the target group won't use them. Regular Expression # Things become complicated when it comes to regular expressions. Not only do we have to understand the syntax of regular expressions (in python) , but we also have to cross the hurdle of configuration language's and Python's character escaping concepts. You can test your (configuration language escaping is not concerned) regular expression on convenient online websites, this website for example. Our advice is try not to use too complex expression, or split one rule with complex expression into multiple rules with simpler ones. User Source Rules # ids # Where to get them? Somehow you can get them from another automatic twitter processing tool. If you want to get one user's id manually, maybe you can find it in the Twitter Web Client 's XHRs via browser developer console? And there are some online websites that allows you to get the id of a user with its name, google \"Twitter user id\" and you'll find them. The type of list elements can be number or string . User Filter Rules # follower, following # At least one of less_than , more_than fields need to be set. This sounds not straightforward, but the less_than needs to be bigger than the more_than because the order of comparison is: more_than < number < less_than The equal-to-edge cases (number=less_than or number=more_then) are regard as falsy (not trigger the rule). User Action Rules # block #","title":"Detailed Plan Configuration"},{"location":"configuration/detailed-plan-configuration/#detailed-plan-configuration","text":"This page contains all details and cautions about plan configuration: which field is required (must be set) in one rule, what value can a field takes... If you are confused about usage of a rule, the answer is most likely written on this page of the documentation. (Can't find what you want? Ask questions to remind us to improve the documentation.)","title":"Detailed Plan Configuration"},{"location":"configuration/detailed-plan-configuration/#tool-scope-concepts","text":"","title":"Tool Scope Concepts"},{"location":"configuration/detailed-plan-configuration/#time-type-values","text":"All the time type values user configured for the tool, generated by the tool, are taken at UTC+0 (i.e. Greenwich Mean Time Zone). (But in general you don't need to be too concerned about a few hours' deviation in filter rules setting or so.) There are three available time formats for configuration: 2022-01-01 01:01:01 -> datetime.datetime(2022, 1, 1, 1, 1, 1) 2022-01-01 -> datetime.date(2022, 1, 1) (the time part is 00:00:00 ) 2022-01-01T01:01:01Z -> datetime.datetime(2022, 1, 1, 1, 1, 1)","title":"Time Type Values"},{"location":"configuration/detailed-plan-configuration/#tips-about-searching-and-matching","text":"For more information about Twitter search queries, please refer to the official documentation . Both tweet search and regular matching are simple yet powerful rules. They are extremely easy to misuse because they just match characters in text rather than the semantics of the text. For example, let's say you want to select people who hate cats and use hate cats as the keyword, but instead you get a match for I hate cockroach!!! Love cats so much \u2665\u2665\u2665\u2665 . Our advice is to carefully choose words that only your target group will say: Use short phrases that are long enough not to confuse semantics but iconic as keywords, such as campaign slogans, taglines or hashtags. Make keywords contain special words that are so highly emotional or so intensely offensive that people outside the target group won't use them.","title":"Tips about Searching and Matching"},{"location":"configuration/detailed-plan-configuration/#regular-expression","text":"Things become complicated when it comes to regular expressions. Not only do we have to understand the syntax of regular expressions (in python) , but we also have to cross the hurdle of configuration language's and Python's character escaping concepts. You can test your (configuration language escaping is not concerned) regular expression on convenient online websites, this website for example. Our advice is try not to use too complex expression, or split one rule with complex expression into multiple rules with simpler ones.","title":"Regular Expression"},{"location":"configuration/detailed-plan-configuration/#user-source-rules","text":"","title":"User Source Rules"},{"location":"configuration/detailed-plan-configuration/#ids","text":"Where to get them? Somehow you can get them from another automatic twitter processing tool. If you want to get one user's id manually, maybe you can find it in the Twitter Web Client 's XHRs via browser developer console? And there are some online websites that allows you to get the id of a user with its name, google \"Twitter user id\" and you'll find them. The type of list elements can be number or string .","title":"ids"},{"location":"configuration/detailed-plan-configuration/#user-filter-rules","text":"","title":"User Filter Rules"},{"location":"configuration/detailed-plan-configuration/#follower-following","text":"At least one of less_than , more_than fields need to be set. This sounds not straightforward, but the less_than needs to be bigger than the more_than because the order of comparison is: more_than < number < less_than The equal-to-edge cases (number=less_than or number=more_then) are regard as falsy (not trigger the rule).","title":"follower, following"},{"location":"configuration/detailed-plan-configuration/#user-action-rules","text":"","title":"User Action Rules"},{"location":"configuration/detailed-plan-configuration/#block","text":"","title":"block"},{"location":"configuration/plan-configuration/","text":"Plan Configuration # This page describes configurations for plan, one run of the tool - setting processing rules through the configuration file (also referred to as Plan). Some rules contain fields that worth a paragraph to explain, but if we put all the details into this single page, it will be too long. So here we just list all the available rules with a brief description, and leave the details in other corresponding pages. The example configuration is written in yaml format (you may want to learn about yaml's syntax ), but you can also use other supported formats like .toml, .ini, .json. In this page we'll use yaml format. Currently, the tool only support processing Twitter accounts (\"user_plan\") (blocking accounts for example), but we left a place for processing tweets in the future (like deleting embarrassing past tweets). How To Write A Plan # One plan contains at most three types of rules, together they construct a processing pipeline: Source rules - Where to get source candidates (Twitter accounts or tweets)? Filter rules - (optional) What type(s) of candidates should be chosen from the source to take actions? Action rules - What actions to take on candidates that trigger filter rules? One plan configuration file can contain several plans (under field plans ). We tried to make plan configuration look natural, one of the simplest is: 1 2 3 4 5 6 7 8 9 10 11 12 13 plans : # Name (explain) of this plan - user_plan : Do block on three users depend on their follower number from : # '@Alice', '@Bob' and '@Charlie' - names : [ 'Alice' , 'Bob' , 'Charlie' ] that : # who has less than 10 (0~9) followers - follower : less_than : 10 do : # block them - block The syntax structure is: 1 2 3 4 5 6 7 8 plans : [ - <plan> ] # <plan> <plan_type> : <string> from : [ <source_rule> ] that : [ <filter_rule> ] do : [ <action_rule> ] As the filter rule is optional, we can directly take action on every user in the source: 1 2 3 4 5 6 plans : - user_plan : Again from : - names : [ 'Alice' , 'Bob' , 'Charlie' ] do : - block How Plans Are Executed # Plans are executed in the order they are defined in the configuration file, one by one i.e. in parallel (so plans won't compete for limited API invocation resources). For a single plan: The source rules are executed first, results are default union together as one final set. Users in the source set are judged by a chain of filter rules, results are default ORed together, so if any filter rule is matched, that user will be considered as the target. The action rules are executed on the target set of users, in the order they are defined in the configuration file. In natural language, the summary is: Run all action_rule s on targets from any source_rule that trigger any filter_rule . You can arrange more complex but flexible execution order by nesting rule sets below. Rule Sets # Rule sets help us create a layer of abstraction by converting a \"scattered\" SET of rules of the same type into a single result. We can think of one single ruleset as a single rule of that type, so that we can write nested \"trees\" of rules with more \"dynamic\" judgment capabilities. For now, we consider that only filter rules are worth writing various (user-usable) rule sets. Rule Sets Inside Plan # In fact, plans use rule sets internally to handle the execution and judgments of the rules contained in themselves, and there are currently two plan-specific rule sets that are not directly available to users: aggregating the candidate targets generated by all source rules into a single data stream and removing duplicate candidate targets. aggregating the results of all action rules into a result set. As described in the plan execution part above, the plan also uses the any_of filter rule set to decide a final single filter result of all filter rules as a basis for determining whether to process candidate targets. any_of (filter rule set) # Logical OR: If any filtering rule is triggered, the rule set is considered to be triggered. Only if none of rules are triggered, the rule set is not triggered. all_of (filter rule set) # Logical AND: Only if all filter rules are triggered, the rule set is considered to be triggered. If any rule is not triggered, the rule set is not triggered. User Source Rules # ids # 1 2 from : - ids : [ 123456789 , 987654321 ] Specify users with a list of user id as source. Details names # 1 2 from : - names : [ 'Alice' , 'Bob' , 'Charlie' ] Specify users with a list of username (also called \"handle\" by Twitter) as source. Usernames are easy to get, so this rule is pretty good for your first try with a handful usernames. Like the user id, manually typing down or parsing amount of usernames is awkward and not recommended. User Filter Rules # follower # 1 2 3 4 5 6 that : - follower : less_than : 10 more_than : 5 - follower_less_than : 10 Follower count itself doesn't tell much, but it's good to have a rule aiming at it. The follower-less-than is a shortcut for follower: { less_than: n } . Details following # 1 2 3 4 5 6 that : - following : less_than : 10 more_than : 5 - following_more_than : 5 Correspondingly... the following number filter rule. Details created # 1 2 3 4 5 6 that : - created : before : 2022-12-01 01:01:01 after : 2022-01-01T01:01:01Z - created_after : 2022-01-01 The creation time of an account is a reflection of how much the Twitter platform trusts that user, and although the Twitter report&suspend mechanism has been unreliable, it is still working. In general, the longer the account is created, the more we \"trust\" that the user is a human rather than a bot. Details about time type values created_within_days # 1 2 that : - created_within_days : 90 Another flexible account creating time judging rule. profile_text_matches # 1 2 that : - profile_text_matches : hate It's actually check three parts of texts, ont only the profile. Check if any text below matches configured regular expression : user's name (the name you see aside the avatar, without \"@\") user's description (also the profile) pinned tweet's text Details about regular expression Make sure you've read tips about how to build a proper match . following_count_ratio # 1 2 3 4 5 6 7 8 9 that : - following_count_ratio : # 1 follower / 10 following more_than : 0.1 # 10 follower / 1 following, wow pretty famous less_than : 10 # 5 follower / 100 following - following_count_ratio_less_than : 0.05 What do you think when you see a user who has a dozen or single digit followers, but follows thousands of people? There's a good chance on just that this person only read and does not talk or interact with others often. But there is a pretty small possibility that this account is a hook or marker. When one user switches from public to protected state, the existing followers can still see the updates, this is the meaning of early following I can think of. tweet_count # 1 2 3 4 5 6 that : - tweet_count : more_than : 10 less_than : 1000 - tweet_count_less_than : 1000 Low tweet count (including retweets) means the user doesn't post much, leave a rule for it. User Action Rules # block # 1 2 do : - block : {} Block users that trigger the filter rules.","title":"Plan Configuration"},{"location":"configuration/plan-configuration/#plan-configuration","text":"This page describes configurations for plan, one run of the tool - setting processing rules through the configuration file (also referred to as Plan). Some rules contain fields that worth a paragraph to explain, but if we put all the details into this single page, it will be too long. So here we just list all the available rules with a brief description, and leave the details in other corresponding pages. The example configuration is written in yaml format (you may want to learn about yaml's syntax ), but you can also use other supported formats like .toml, .ini, .json. In this page we'll use yaml format. Currently, the tool only support processing Twitter accounts (\"user_plan\") (blocking accounts for example), but we left a place for processing tweets in the future (like deleting embarrassing past tweets).","title":"Plan Configuration"},{"location":"configuration/plan-configuration/#how-to-write-a-plan","text":"One plan contains at most three types of rules, together they construct a processing pipeline: Source rules - Where to get source candidates (Twitter accounts or tweets)? Filter rules - (optional) What type(s) of candidates should be chosen from the source to take actions? Action rules - What actions to take on candidates that trigger filter rules? One plan configuration file can contain several plans (under field plans ). We tried to make plan configuration look natural, one of the simplest is: 1 2 3 4 5 6 7 8 9 10 11 12 13 plans : # Name (explain) of this plan - user_plan : Do block on three users depend on their follower number from : # '@Alice', '@Bob' and '@Charlie' - names : [ 'Alice' , 'Bob' , 'Charlie' ] that : # who has less than 10 (0~9) followers - follower : less_than : 10 do : # block them - block The syntax structure is: 1 2 3 4 5 6 7 8 plans : [ - <plan> ] # <plan> <plan_type> : <string> from : [ <source_rule> ] that : [ <filter_rule> ] do : [ <action_rule> ] As the filter rule is optional, we can directly take action on every user in the source: 1 2 3 4 5 6 plans : - user_plan : Again from : - names : [ 'Alice' , 'Bob' , 'Charlie' ] do : - block","title":"How To Write A Plan"},{"location":"configuration/plan-configuration/#how-plans-are-executed","text":"Plans are executed in the order they are defined in the configuration file, one by one i.e. in parallel (so plans won't compete for limited API invocation resources). For a single plan: The source rules are executed first, results are default union together as one final set. Users in the source set are judged by a chain of filter rules, results are default ORed together, so if any filter rule is matched, that user will be considered as the target. The action rules are executed on the target set of users, in the order they are defined in the configuration file. In natural language, the summary is: Run all action_rule s on targets from any source_rule that trigger any filter_rule . You can arrange more complex but flexible execution order by nesting rule sets below.","title":"How Plans Are Executed"},{"location":"configuration/plan-configuration/#rule-sets","text":"Rule sets help us create a layer of abstraction by converting a \"scattered\" SET of rules of the same type into a single result. We can think of one single ruleset as a single rule of that type, so that we can write nested \"trees\" of rules with more \"dynamic\" judgment capabilities. For now, we consider that only filter rules are worth writing various (user-usable) rule sets.","title":"Rule Sets"},{"location":"configuration/plan-configuration/#rule-sets-inside-plan","text":"In fact, plans use rule sets internally to handle the execution and judgments of the rules contained in themselves, and there are currently two plan-specific rule sets that are not directly available to users: aggregating the candidate targets generated by all source rules into a single data stream and removing duplicate candidate targets. aggregating the results of all action rules into a result set. As described in the plan execution part above, the plan also uses the any_of filter rule set to decide a final single filter result of all filter rules as a basis for determining whether to process candidate targets.","title":"Rule Sets Inside Plan"},{"location":"configuration/plan-configuration/#any_of-filter-rule-set","text":"Logical OR: If any filtering rule is triggered, the rule set is considered to be triggered. Only if none of rules are triggered, the rule set is not triggered.","title":"any_of (filter rule set)"},{"location":"configuration/plan-configuration/#all_of-filter-rule-set","text":"Logical AND: Only if all filter rules are triggered, the rule set is considered to be triggered. If any rule is not triggered, the rule set is not triggered.","title":"all_of (filter rule set)"},{"location":"configuration/plan-configuration/#user-source-rules","text":"","title":"User Source Rules"},{"location":"configuration/plan-configuration/#ids","text":"1 2 from : - ids : [ 123456789 , 987654321 ] Specify users with a list of user id as source. Details","title":"ids"},{"location":"configuration/plan-configuration/#names","text":"1 2 from : - names : [ 'Alice' , 'Bob' , 'Charlie' ] Specify users with a list of username (also called \"handle\" by Twitter) as source. Usernames are easy to get, so this rule is pretty good for your first try with a handful usernames. Like the user id, manually typing down or parsing amount of usernames is awkward and not recommended.","title":"names"},{"location":"configuration/plan-configuration/#user-filter-rules","text":"","title":"User Filter Rules"},{"location":"configuration/plan-configuration/#follower","text":"1 2 3 4 5 6 that : - follower : less_than : 10 more_than : 5 - follower_less_than : 10 Follower count itself doesn't tell much, but it's good to have a rule aiming at it. The follower-less-than is a shortcut for follower: { less_than: n } . Details","title":"follower"},{"location":"configuration/plan-configuration/#following","text":"1 2 3 4 5 6 that : - following : less_than : 10 more_than : 5 - following_more_than : 5 Correspondingly... the following number filter rule. Details","title":"following"},{"location":"configuration/plan-configuration/#created","text":"1 2 3 4 5 6 that : - created : before : 2022-12-01 01:01:01 after : 2022-01-01T01:01:01Z - created_after : 2022-01-01 The creation time of an account is a reflection of how much the Twitter platform trusts that user, and although the Twitter report&suspend mechanism has been unreliable, it is still working. In general, the longer the account is created, the more we \"trust\" that the user is a human rather than a bot. Details about time type values","title":"created"},{"location":"configuration/plan-configuration/#created_within_days","text":"1 2 that : - created_within_days : 90 Another flexible account creating time judging rule.","title":"created_within_days"},{"location":"configuration/plan-configuration/#profile_text_matches","text":"1 2 that : - profile_text_matches : hate It's actually check three parts of texts, ont only the profile. Check if any text below matches configured regular expression : user's name (the name you see aside the avatar, without \"@\") user's description (also the profile) pinned tweet's text Details about regular expression Make sure you've read tips about how to build a proper match .","title":"profile_text_matches"},{"location":"configuration/plan-configuration/#following_count_ratio","text":"1 2 3 4 5 6 7 8 9 that : - following_count_ratio : # 1 follower / 10 following more_than : 0.1 # 10 follower / 1 following, wow pretty famous less_than : 10 # 5 follower / 100 following - following_count_ratio_less_than : 0.05 What do you think when you see a user who has a dozen or single digit followers, but follows thousands of people? There's a good chance on just that this person only read and does not talk or interact with others often. But there is a pretty small possibility that this account is a hook or marker. When one user switches from public to protected state, the existing followers can still see the updates, this is the meaning of early following I can think of.","title":"following_count_ratio"},{"location":"configuration/plan-configuration/#tweet_count","text":"1 2 3 4 5 6 that : - tweet_count : more_than : 10 less_than : 1000 - tweet_count_less_than : 1000 Low tweet count (including retweets) means the user doesn't post much, leave a rule for it.","title":"tweet_count"},{"location":"configuration/plan-configuration/#user-action-rules","text":"","title":"User Action Rules"},{"location":"configuration/plan-configuration/#block","text":"1 2 do : - block : {} Block users that trigger the filter rules.","title":"block"},{"location":"configuration/tool-configuration/","text":"Tool Configuration # This page is describing configurations of the tool itself. For all available plan configurations, please check the plan configuration documentation page . There are two types of tool configuration: most of them can be configured in global configuration file or set via environment variable, but some special configurations can only be passed through command line argument. The tool is using the Dynaconf as the configuration parsing library. Loading Priority (Precedence) # The tool will choose the tool configurations in the following order: Command line arguments & Environment variables[ ref ]. User written plan configuration files. Global settings file and secrets file. Default values set inside program. Setting via Configuration File # You can use different supported formats like .yaml, .toml, .ini, .json. In this page we'll use yaml format. The name of one setting option is also the key in configuration file, and you can set an environment variable for it. Name Default Description log_level info Log level of the log file and stderr log_rotation 100MB Change log files writing method (when to split a new file) block_following false Whether to block users that you're following block_follower true Whether to block users that following you read_password_from_stdin false Instead of ask user input the password (for loading private key file) through terminal You can search how particular configuration is used in source code if you are interested. Setting via Environment Variable # You can set the tool configurations via setting environment variables , with the prefix BULLET_ followed by upper case of the name, in which you can build automated processes. This is quite useful and simple when setting up secrets. 1 2 3 4 5 # setting in configuration file (yaml) caliber: 20 ga. # variable in environment (unix-like os style) export BULLET_CALIBER=\"20 ga.\" Secrets # Secrets are strings that need to be kept well, and you should treat them as you would your Twitter account's password. Anyone who has them can manipulate your Twitter account at will just like they have your password. We need four (two pairs of) secrets to make the tool work: A pair of Twitter Developer API usage credential for querying Twitter APIs, configuration name: ak & aks , stands for A pi K ey secrets pair key and key S ecrets. We'll get them from Twitter Dev Platform . An access token pair that indicate your consent for API key above to operate your account, configuration name: at & ats , stands for A ccess T oken pair key and key S ecrets. We can't get them until first run the tool. Registering a Twitter API Credential # When the tool is first launched there is an interactive guide procedure instructing you on how to register and save your credentials. If you want to register one right away, keep reading, if not, skip this paragraph. For registering a credential, first you need a Twitter account (you already have one I guess), and you need to bind a phone number with that account. You can do unbind after get the credential, and the credential will remain valid. But Twitter already saved a new line of record about your phone inside the user table, now it's up to you whether you want to continue or not. Follow the instruction below: Register the credential (\"register an app\" Twitter says so) on developer.twitter.com . Turn on \"OAuth 1.0a\" in your App settings: Set the App permissions to \"Read and write\". Set the callback, website URL to \"https://twitter.com\" for passing the website's validation check. (We'll use the pin-based auth method , so we needn't really deploy a server for receiving Twitter's callback.) All set, now you can directly paste them into the tool, run puntgun gen secrets to configurate secrets. You must run the tool at least once to authorize this tool with your Twitter account to get access token pair, then you can dump secrets and set all these four secrets for automatically running the tool. Let the Tool Manages Secrets # The tool will help you manage secrets by default, and interactive with you via terminal (command line interface) while running to operate them. In short, you create a new password and keep it, the password protects the <private_key_file> , the private key protects four secret values in <secrets_file> . You keep the password, let the tool arrange rest things for you. Keep reading if you interest about details or skip if you don't. First we talk about secrets saving. If the tool can't find some secrets in environment variables, it will ask you to input secrets through terminal, then save all secrets into an encrypted file (named as <secrets_file> ), sort of like put them into a chest and lock the chest. No one can figure out the secret values even they can read the <secrets_file> , there are just meaningless ciphertext, no plain text. Stay in simple, for encrypting that <secrets_file> , we'll need a private key (another secret value), the tool will automatically generate one for you. This private key (with the public key it generates) can act as both \"key\" and \"lock\" of the <secrets_file> \"chest\". We can't remember, and it's inconvenient to re-input this long value, so we need to save this value down to a file, or we'll lose it after reboot the computer like your poor office files, so here is the second file - <private_key_file> . It may disappoint you but, for saving the private key into the <private_key_file> we need another password (passphrase) to protect the dumped value, this time it's short and human-readable just like other normal passwords, it's created and inputted by you, and you should remember it for future use. Make sense? Loading secrets when restart the tool afterwards is in plain reversed order. You enter the password (through terminal), the tool load the private key, use the private key load secrets, done. For more security concern, read this paragraph . Setting Secrets via Other Methods for Automation # The tool's \"require-input-password-to-decrypt-secrets\" interaction behavior will block the program. So here are some other ways to set secrets for integrating this tool into automating process. You'll provide plain text format secret values with these methods, so we'd like to remind you to keep secrets safe from bad guys. Four secrets in total: ak , aks , at , ats , you must provide both four secrets or the tool will still ask you for remains. You can provide ak , aks and at , ats via different approach if you want. You can indicate a file path with --secrets_file command line argument when starting the tool, in which contains secrets configured like other normal configuration options. (You can even directly write these secrets in you plan file and the tool still can load them, but that's dangerous and not recommended.) You can set environment variables for them. You can pass your private key file's password through stdin , the tool will read the password from stdin instead of ask password interactively when the read_password_from_stdin tool setting is set to true .","title":"Tool Configuration"},{"location":"configuration/tool-configuration/#tool-configuration","text":"This page is describing configurations of the tool itself. For all available plan configurations, please check the plan configuration documentation page . There are two types of tool configuration: most of them can be configured in global configuration file or set via environment variable, but some special configurations can only be passed through command line argument. The tool is using the Dynaconf as the configuration parsing library.","title":"Tool Configuration"},{"location":"configuration/tool-configuration/#loading-priority-precedence","text":"The tool will choose the tool configurations in the following order: Command line arguments & Environment variables[ ref ]. User written plan configuration files. Global settings file and secrets file. Default values set inside program.","title":"Loading Priority (Precedence)"},{"location":"configuration/tool-configuration/#setting-via-configuration-file","text":"You can use different supported formats like .yaml, .toml, .ini, .json. In this page we'll use yaml format. The name of one setting option is also the key in configuration file, and you can set an environment variable for it. Name Default Description log_level info Log level of the log file and stderr log_rotation 100MB Change log files writing method (when to split a new file) block_following false Whether to block users that you're following block_follower true Whether to block users that following you read_password_from_stdin false Instead of ask user input the password (for loading private key file) through terminal You can search how particular configuration is used in source code if you are interested.","title":"Setting via Configuration File"},{"location":"configuration/tool-configuration/#setting-via-environment-variable","text":"You can set the tool configurations via setting environment variables , with the prefix BULLET_ followed by upper case of the name, in which you can build automated processes. This is quite useful and simple when setting up secrets. 1 2 3 4 5 # setting in configuration file (yaml) caliber: 20 ga. # variable in environment (unix-like os style) export BULLET_CALIBER=\"20 ga.\"","title":"Setting via Environment Variable"},{"location":"configuration/tool-configuration/#secrets","text":"Secrets are strings that need to be kept well, and you should treat them as you would your Twitter account's password. Anyone who has them can manipulate your Twitter account at will just like they have your password. We need four (two pairs of) secrets to make the tool work: A pair of Twitter Developer API usage credential for querying Twitter APIs, configuration name: ak & aks , stands for A pi K ey secrets pair key and key S ecrets. We'll get them from Twitter Dev Platform . An access token pair that indicate your consent for API key above to operate your account, configuration name: at & ats , stands for A ccess T oken pair key and key S ecrets. We can't get them until first run the tool.","title":"Secrets"},{"location":"configuration/tool-configuration/#registering-a-twitter-api-credential","text":"When the tool is first launched there is an interactive guide procedure instructing you on how to register and save your credentials. If you want to register one right away, keep reading, if not, skip this paragraph. For registering a credential, first you need a Twitter account (you already have one I guess), and you need to bind a phone number with that account. You can do unbind after get the credential, and the credential will remain valid. But Twitter already saved a new line of record about your phone inside the user table, now it's up to you whether you want to continue or not. Follow the instruction below: Register the credential (\"register an app\" Twitter says so) on developer.twitter.com . Turn on \"OAuth 1.0a\" in your App settings: Set the App permissions to \"Read and write\". Set the callback, website URL to \"https://twitter.com\" for passing the website's validation check. (We'll use the pin-based auth method , so we needn't really deploy a server for receiving Twitter's callback.) All set, now you can directly paste them into the tool, run puntgun gen secrets to configurate secrets. You must run the tool at least once to authorize this tool with your Twitter account to get access token pair, then you can dump secrets and set all these four secrets for automatically running the tool.","title":"Registering a Twitter API Credential"},{"location":"configuration/tool-configuration/#let-the-tool-manages-secrets","text":"The tool will help you manage secrets by default, and interactive with you via terminal (command line interface) while running to operate them. In short, you create a new password and keep it, the password protects the <private_key_file> , the private key protects four secret values in <secrets_file> . You keep the password, let the tool arrange rest things for you. Keep reading if you interest about details or skip if you don't. First we talk about secrets saving. If the tool can't find some secrets in environment variables, it will ask you to input secrets through terminal, then save all secrets into an encrypted file (named as <secrets_file> ), sort of like put them into a chest and lock the chest. No one can figure out the secret values even they can read the <secrets_file> , there are just meaningless ciphertext, no plain text. Stay in simple, for encrypting that <secrets_file> , we'll need a private key (another secret value), the tool will automatically generate one for you. This private key (with the public key it generates) can act as both \"key\" and \"lock\" of the <secrets_file> \"chest\". We can't remember, and it's inconvenient to re-input this long value, so we need to save this value down to a file, or we'll lose it after reboot the computer like your poor office files, so here is the second file - <private_key_file> . It may disappoint you but, for saving the private key into the <private_key_file> we need another password (passphrase) to protect the dumped value, this time it's short and human-readable just like other normal passwords, it's created and inputted by you, and you should remember it for future use. Make sense? Loading secrets when restart the tool afterwards is in plain reversed order. You enter the password (through terminal), the tool load the private key, use the private key load secrets, done. For more security concern, read this paragraph .","title":"Let the Tool Manages Secrets"},{"location":"configuration/tool-configuration/#setting-secrets-via-other-methods-for-automation","text":"The tool's \"require-input-password-to-decrypt-secrets\" interaction behavior will block the program. So here are some other ways to set secrets for integrating this tool into automating process. You'll provide plain text format secret values with these methods, so we'd like to remind you to keep secrets safe from bad guys. Four secrets in total: ak , aks , at , ats , you must provide both four secrets or the tool will still ask you for remains. You can provide ak , aks and at , ats via different approach if you want. You can indicate a file path with --secrets_file command line argument when starting the tool, in which contains secrets configured like other normal configuration options. (You can even directly write these secrets in you plan file and the tool still can load them, but that's dangerous and not recommended.) You can set environment variables for them. You can pass your private key file's password through stdin , the tool will read the password from stdin instead of ask password interactively when the read_password_from_stdin tool setting is set to true .","title":"Setting Secrets via Other Methods for Automation"},{"location":"development/contributing/","text":"Contributing to the puntgun # Thank you for considering making this tool better. You'll need a GitHub account to participate in contribution, which can be an obstacle, and I apologize for that. You can also email me (I generally check email once a week), but it is difficult for me personally to reply to everyone appropriately, so please consider this as a backup option only. There is no strict limit to how and what you can contribute, here are a few ways we can think of. Programming aspect # Improving unsatisfied code: There are some unsatisfactory code pieces, they work, but they deserve to be better. You can find them by searching for IMPROVE marks in the code. Join the discussion about or deal with unclosed issues . Develop new features to this tool (and we recommend developing in the steps described below ). Improve CI/CD process. Add more test cases. For local development, please read this part . For security and vulnerability reports, please read this documentation . Non-programming aspect # Improving documentation : Make documentation easier to understand by changing expressions. Fixing syntax and typo errors in documentation. Add more necessary details for the user to know the specific behavior of the tool without having to read the code. Join the community on the GitHub: Help others by answering questions . Request or vote new features (the more details the better!). Share good plan configuration and automation usage. Recommended contributing approaches # Tell us what you intend to do before finishing it # When you decide to make programming aspect contributions, we expect you to indicate in the corresponding issue or new issue that you intend to do this and how you intend to implement it, like this article . Industry experience tells us that shift-left checks and discussions is good for software development, for example we can provide more relevant knowledge, project details and advice to help you do things better when we know what you want to do. Of course there is no mandatory requirement (compliments of the freewheeling open source community !), the code for this project is open source under the MIT license , and you do not need to get anyone's permission to make changes to (your fork of) this project, you just need to make it work for your personal needs . If you feel that your changes will also benefit the upstream, you can submit a Pull Request to the upstream, and only then does the \"contributing\" begin. PR should pass lint checks and unit test suite # Remember to run pdm run lint and pdm run test to make sure all checks pass before creating Pull Request, the CI will fail if any lint tool complains. Remember to write changelog # There is a CHANGELOG.md file under the project root directory that is used to record changes, please modify this file correspondingly when you commit the Pull Request. The contents of this file will be copied by release CI to the GitHub Release when the version is released. The maintainer will manually check the change logs before the release, so there is no need to get too hung up on the details of change log writing. Summarize your change in an imperative or descriptive sentence (just like a commit message: Fix... [#issue-number] , follower - new user filter rule for... ), and try to keep it both short and specific, with specificity taking precedence. Check the Change Log file for more examples. The Change Log has the following categories (create if current release does not have the category titles you need): Features : New rules, new command line options... what users can sense Removals : Removals or deprecations, what users can sense Improvements : Code refactors, better error handling... changes on existing code, CI, tests... Bug Fixes : Newly closed bug issues Documentation : Documentation updates Dependencies : Changes to dependencies Miscellany : Changes that don't fit any of the other categories Although uncommon, there are cases where one change involves multiple categories, in these cases multiple change logs can be written correspondingly. For reference, here are some common cases with treatments: Modifying documentation while modifying code : Omitting Documentation change log Modified dependencies while modifying code : Write both code modification and Dependencies change logs Modifying existing code while adding new features : Write both Features and Improvements change logs Prepare for local development # This project requires Python version 3.10 or above. If you are not familiar with how to clone a project and submit a Pull Request using GitHub, please read this documentation from GitHub official . (Sorry to be abrupt, but... pipx is an excellent tool for managing executable python libraries, you may want to use it instead of pip for installing pypi-based executable tools. Almost all tools used in the project can be happily installed in this convenient way, though they will be well cared by other managing tools, so you need not manually install them while you using scripts. If you install them with pipx in addition to venv and PDM , you can use them anywhere, that is convenient.) This project uses the PDM as package managing tool, if you are not skilled enough to use other package management tools to be compatible with the PDM configuration (scripts defined in pyproject.toml , etc.), install the PDM . PDM will detect and reuses the virtualenv python environment under the project directory, so you can write code with your PDM-not-supported IDEs (PyCharm for example) in virtualenv style, while using PDM truly managing everything via terminal. Now simply install all dependencies with pdm install . All set, now you can play with the code or get your hands dirty to make things happen. Scripts and tools for development # All development scripts are defined under [tool.pdm.scripts] section in pyproject.toml . Run tests # 1 pdm run test This project uses pytest as the unit testing framework, which will be installed with development dependencies. Test cases are written under ./tests directory with test_ prefix. 1 pdm run coverage This script will run the test suite with pytest while generating a html format coverage report with coverage.py . Linting # Warning Running this script will actually change the code , make sure commit your code before running. 1 pdm run lint This project uses pre-commit for linting , it will help us to manage other linting tools. Check .pre-commit-config.yaml under root directory to see pre-commit hooks configuration. Currently, this project uses: pyupgrade for automatically upgrade the syntax. black for code style automatic formatting. isort for import statements sorting. codespell for typo checking. flake8 for common Python programming problem checking. mypy for static type hint scanning. As we all know, the rigid linting results sometimes does not make sense or have false positives, if your changes encounter unreasonable linting results, feel free to modify the configuration of the corresponding tool. Render the documentation website # 1 pdm run doc This project uses MkDocs as documentation website framework, with Material for MkDocs as website theme. They will also be installed with development dependencies. Documentation source is written in Markdown format, under ./docs directory.","title":"Contributing"},{"location":"development/contributing/#contributing-to-the-puntgun","text":"Thank you for considering making this tool better. You'll need a GitHub account to participate in contribution, which can be an obstacle, and I apologize for that. You can also email me (I generally check email once a week), but it is difficult for me personally to reply to everyone appropriately, so please consider this as a backup option only. There is no strict limit to how and what you can contribute, here are a few ways we can think of.","title":"Contributing to the puntgun"},{"location":"development/contributing/#programming-aspect","text":"Improving unsatisfied code: There are some unsatisfactory code pieces, they work, but they deserve to be better. You can find them by searching for IMPROVE marks in the code. Join the discussion about or deal with unclosed issues . Develop new features to this tool (and we recommend developing in the steps described below ). Improve CI/CD process. Add more test cases. For local development, please read this part . For security and vulnerability reports, please read this documentation .","title":"Programming aspect"},{"location":"development/contributing/#non-programming-aspect","text":"Improving documentation : Make documentation easier to understand by changing expressions. Fixing syntax and typo errors in documentation. Add more necessary details for the user to know the specific behavior of the tool without having to read the code. Join the community on the GitHub: Help others by answering questions . Request or vote new features (the more details the better!). Share good plan configuration and automation usage.","title":"Non-programming aspect"},{"location":"development/contributing/#recommended-contributing-approaches","text":"","title":"Recommended contributing approaches"},{"location":"development/contributing/#tell-us-what-you-intend-to-do-before-finishing-it","text":"When you decide to make programming aspect contributions, we expect you to indicate in the corresponding issue or new issue that you intend to do this and how you intend to implement it, like this article . Industry experience tells us that shift-left checks and discussions is good for software development, for example we can provide more relevant knowledge, project details and advice to help you do things better when we know what you want to do. Of course there is no mandatory requirement (compliments of the freewheeling open source community !), the code for this project is open source under the MIT license , and you do not need to get anyone's permission to make changes to (your fork of) this project, you just need to make it work for your personal needs . If you feel that your changes will also benefit the upstream, you can submit a Pull Request to the upstream, and only then does the \"contributing\" begin.","title":"Tell us what you intend to do before finishing it"},{"location":"development/contributing/#pr-should-pass-lint-checks-and-unit-test-suite","text":"Remember to run pdm run lint and pdm run test to make sure all checks pass before creating Pull Request, the CI will fail if any lint tool complains.","title":"PR should pass lint checks and unit test suite"},{"location":"development/contributing/#remember-to-write-changelog","text":"There is a CHANGELOG.md file under the project root directory that is used to record changes, please modify this file correspondingly when you commit the Pull Request. The contents of this file will be copied by release CI to the GitHub Release when the version is released. The maintainer will manually check the change logs before the release, so there is no need to get too hung up on the details of change log writing. Summarize your change in an imperative or descriptive sentence (just like a commit message: Fix... [#issue-number] , follower - new user filter rule for... ), and try to keep it both short and specific, with specificity taking precedence. Check the Change Log file for more examples. The Change Log has the following categories (create if current release does not have the category titles you need): Features : New rules, new command line options... what users can sense Removals : Removals or deprecations, what users can sense Improvements : Code refactors, better error handling... changes on existing code, CI, tests... Bug Fixes : Newly closed bug issues Documentation : Documentation updates Dependencies : Changes to dependencies Miscellany : Changes that don't fit any of the other categories Although uncommon, there are cases where one change involves multiple categories, in these cases multiple change logs can be written correspondingly. For reference, here are some common cases with treatments: Modifying documentation while modifying code : Omitting Documentation change log Modified dependencies while modifying code : Write both code modification and Dependencies change logs Modifying existing code while adding new features : Write both Features and Improvements change logs","title":"Remember to write changelog"},{"location":"development/contributing/#prepare-for-local-development","text":"This project requires Python version 3.10 or above. If you are not familiar with how to clone a project and submit a Pull Request using GitHub, please read this documentation from GitHub official . (Sorry to be abrupt, but... pipx is an excellent tool for managing executable python libraries, you may want to use it instead of pip for installing pypi-based executable tools. Almost all tools used in the project can be happily installed in this convenient way, though they will be well cared by other managing tools, so you need not manually install them while you using scripts. If you install them with pipx in addition to venv and PDM , you can use them anywhere, that is convenient.) This project uses the PDM as package managing tool, if you are not skilled enough to use other package management tools to be compatible with the PDM configuration (scripts defined in pyproject.toml , etc.), install the PDM . PDM will detect and reuses the virtualenv python environment under the project directory, so you can write code with your PDM-not-supported IDEs (PyCharm for example) in virtualenv style, while using PDM truly managing everything via terminal. Now simply install all dependencies with pdm install . All set, now you can play with the code or get your hands dirty to make things happen.","title":"Prepare for local development"},{"location":"development/contributing/#scripts-and-tools-for-development","text":"All development scripts are defined under [tool.pdm.scripts] section in pyproject.toml .","title":"Scripts and tools for development"},{"location":"development/contributing/#run-tests","text":"1 pdm run test This project uses pytest as the unit testing framework, which will be installed with development dependencies. Test cases are written under ./tests directory with test_ prefix. 1 pdm run coverage This script will run the test suite with pytest while generating a html format coverage report with coverage.py .","title":"Run tests"},{"location":"development/contributing/#linting","text":"Warning Running this script will actually change the code , make sure commit your code before running. 1 pdm run lint This project uses pre-commit for linting , it will help us to manage other linting tools. Check .pre-commit-config.yaml under root directory to see pre-commit hooks configuration. Currently, this project uses: pyupgrade for automatically upgrade the syntax. black for code style automatic formatting. isort for import statements sorting. codespell for typo checking. flake8 for common Python programming problem checking. mypy for static type hint scanning. As we all know, the rigid linting results sometimes does not make sense or have false positives, if your changes encounter unreasonable linting results, feel free to modify the configuration of the corresponding tool.","title":"Linting"},{"location":"development/contributing/#render-the-documentation-website","text":"1 pdm run doc This project uses MkDocs as documentation website framework, with Material for MkDocs as website theme. They will also be installed with development dependencies. Documentation source is written in Markdown format, under ./docs directory.","title":"Render the documentation website"},{"location":"development/custom-rules/","text":"Custom Rules # This page describes knowledge about developing custom rules. This tool is distributed as a standalone application, you cannot add rules by modifying the source code, so first please follow this documentation to make your local development environment ready. Structure of rules source code # All rule-related code are stored under the rules module. Depending on the type of entity that the rule operates, rules are divided into two categories: user rules and tweet rules, which are stored in the corresponding user and tweet submodules. The rules are further categorized by the purpose (source, filter, action...) and stored in different modules. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [../puntgun/puntgun/rules \u2039main*\u203a] $ tree . \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 config_parser.py \u251c\u2500\u2500 data.py \u251c\u2500\u2500 tweet \u2502 \u2514\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 user \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 action_rules.py \u251c\u2500\u2500 filter_rules.py \u251c\u2500\u2500 plan.py \u251c\u2500\u2500 rule_sets.py \u2514\u2500\u2500 source_rules.py Inheritance structure of one example rule class # This project is developed using object-oriented design pattern, and each rule exists in the form of a class structure. Take example from inheritance diagram of \"FollowerUserFilterRule\": 1 2 3 4 5 6 7 8 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba BaseModel \u2502 \u25b2 \u2502 \u2502 FieldsRequired \u25c4\u2500\u2500\u252c\u2500\u2500\u2500\u25ba FromConfig \u25c4\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 NumericRangeCheckingMixin \u25c4\u2500\u2500\u252c\u2500\u2500\u2500\u25ba UserFilterRule \u2502 FollowerUserFilterRule Class Position Purpose FollowerUserFilterRule rules.user.filter_rules User filter rule, for checking if user's follower count within given range NumericRangeCheckingMixin rules.__init__ Reusable class which providing range checking function on numeric type value UserFilterRule rules.user.filter_rules Rule type tagging for runtime rule classes loading FieldsRequired rules.__init__ Contain an auto-validating function to check at least one field is provided with configuration FromConfig rules.__init__ Indicate that one class can be parsed from loaded plan configuration (Python dictionary type) BaseModel pydantic (dependency) Use this dependency to get easy instance initialization and field values validation capabilities We reuse the functions through the mixin practice, so the final rule implementation will be simple (if it doesn't need additional logic): 1 2 3 4 5 6 7 8 9 10 11 12 13 class FollowerUserFilterRule ( NumericRangeCheckingMixin , UserFilterRule ): \"\"\"Check user's follower count.\"\"\" # Inherits from [FromConfig]. # Same-name in plan configuration, works like index of rule classes for configuration parsing, # let the configuration parser knows which rule class the configuration should be parsed to. _keyword : ClassVar [ str ] = \"follower\" # Overrides from [UserFilterRule]. # Returns a wrapper DTO which contains itself (for latter reporting) and the filtering result. def __call__ ( self , user : User ) -> RuleResult : # call NumericRangeCheckingMixin.compare() return RuleResult ( self , super () . compare ( user . followers_count )) To create instances of this class: 1 2 3 4 5 6 7 8 9 10 11 12 13 # 1. Normal way # Two initializing parameters are inherited from [NumericRangeCheckingMixin] r = FollowerUserFilterRule ( less_than = 100 , more_than = 1 ) # 2. Parse from configuration # using BaseModel.parse_obj() # https://pydantic-docs.helpmanual.io/usage/models/#helper-functions # # follower: # less_than: 100 # more_than: 1 # r = FollowerUserFilterRule . parse_obj ({ \"follower\" : { \"less_than\" : 100 , \"more_than\" : 1 }}) In the rule class developing we use quite a few features provided by pydantic . For the most part using pydantic speed-up our development, but it made the rule class has unknown behavior, and implementing some simple features on the rule class (such as adding _keyword class variable ) required more time reading the documentation and experimenting. Take it as a trade-off. How the rule instances are generated from the plan configuration # Since the exact logic may change in the future, the description here does not involve specific implementation. The description will be given with the following plan configuration. 1 2 3 4 5 6 7 8 9 10 11 plans: - user_plan: Name #(3) from: - names: ['TwitterDev', 'TwitterAPI'] that: - follower: #(4) less_than: 10 - following: more_than: 100000000 do: - block: {} When the program starts, Python loads module rules.config_parser into the namespace, the function call written in the global environment in module rules.config_parser are executed, loads all the rule classes (all classes inherited FromConfig , in fact, including plan classes, etc.) in module rules recursively in runtime (simply import all classes in this module will cause circular dependency problem, while move importing to other upper modules looks awkward). Once the program takes the plan configuration (in Python dictionary type) from the full configuration, the program will recursively parse the plan configuration using the ConfigParser under the rules.config_parser module, converting it into a list of plan instances which contain rule instances. The ConfigParser matching configuration and rules with the help of inheritance chain of rule classes and _keyword class variables of each rule class. The first step is to parse the root of the plan configuration (Python dictionary) i.e. the plan class, which inherit from the Plan parent class, so we know that all Plan 's subclasses are candidates for this step (and it is hard-coded). Now assuming that the root of first plan configuration is \"user_plan\", we'll look for the subclass which _keyword 's value is exactly user_plan , and it turns out to be the UserPlan class (if no answer occur, the ConfigParser will raise an error). Now the ConfigParser knows that it should try to pass the configuration to UserPlan 's constructor. Inside UserPlan 's constructor, the ConfigParser is called again for parsing rules inside this plan instance. This time the ConfigParser is given UserSourceRule , UserFilterRule , UserActionRule as candidate transforming targets' parent classes, and the ConfigParser will again search for the same _keyword class variables. For example, UserFilterRule + _keyword:follower => FollowerUserFilterRule . Repeating step 3 and step 4, whole plan configuration dictionary is transformed into plan instances. Possible construction and parsing errors are caught and collected outside the ConfigParser invoking logic. If no errors occur during the whole parsing process, the program will start executing the plan, otherwise the program will exit and print these errors to notify the user to fix them.","title":"Custom Rules"},{"location":"development/custom-rules/#custom-rules","text":"This page describes knowledge about developing custom rules. This tool is distributed as a standalone application, you cannot add rules by modifying the source code, so first please follow this documentation to make your local development environment ready.","title":"Custom Rules"},{"location":"development/custom-rules/#structure-of-rules-source-code","text":"All rule-related code are stored under the rules module. Depending on the type of entity that the rule operates, rules are divided into two categories: user rules and tweet rules, which are stored in the corresponding user and tweet submodules. The rules are further categorized by the purpose (source, filter, action...) and stored in different modules. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [../puntgun/puntgun/rules \u2039main*\u203a] $ tree . \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 config_parser.py \u251c\u2500\u2500 data.py \u251c\u2500\u2500 tweet \u2502 \u2514\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 user \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 action_rules.py \u251c\u2500\u2500 filter_rules.py \u251c\u2500\u2500 plan.py \u251c\u2500\u2500 rule_sets.py \u2514\u2500\u2500 source_rules.py","title":"Structure of rules source code"},{"location":"development/custom-rules/#inheritance-structure-of-one-example-rule-class","text":"This project is developed using object-oriented design pattern, and each rule exists in the form of a class structure. Take example from inheritance diagram of \"FollowerUserFilterRule\": 1 2 3 4 5 6 7 8 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba BaseModel \u2502 \u25b2 \u2502 \u2502 FieldsRequired \u25c4\u2500\u2500\u252c\u2500\u2500\u2500\u25ba FromConfig \u25c4\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 NumericRangeCheckingMixin \u25c4\u2500\u2500\u252c\u2500\u2500\u2500\u25ba UserFilterRule \u2502 FollowerUserFilterRule Class Position Purpose FollowerUserFilterRule rules.user.filter_rules User filter rule, for checking if user's follower count within given range NumericRangeCheckingMixin rules.__init__ Reusable class which providing range checking function on numeric type value UserFilterRule rules.user.filter_rules Rule type tagging for runtime rule classes loading FieldsRequired rules.__init__ Contain an auto-validating function to check at least one field is provided with configuration FromConfig rules.__init__ Indicate that one class can be parsed from loaded plan configuration (Python dictionary type) BaseModel pydantic (dependency) Use this dependency to get easy instance initialization and field values validation capabilities We reuse the functions through the mixin practice, so the final rule implementation will be simple (if it doesn't need additional logic): 1 2 3 4 5 6 7 8 9 10 11 12 13 class FollowerUserFilterRule ( NumericRangeCheckingMixin , UserFilterRule ): \"\"\"Check user's follower count.\"\"\" # Inherits from [FromConfig]. # Same-name in plan configuration, works like index of rule classes for configuration parsing, # let the configuration parser knows which rule class the configuration should be parsed to. _keyword : ClassVar [ str ] = \"follower\" # Overrides from [UserFilterRule]. # Returns a wrapper DTO which contains itself (for latter reporting) and the filtering result. def __call__ ( self , user : User ) -> RuleResult : # call NumericRangeCheckingMixin.compare() return RuleResult ( self , super () . compare ( user . followers_count )) To create instances of this class: 1 2 3 4 5 6 7 8 9 10 11 12 13 # 1. Normal way # Two initializing parameters are inherited from [NumericRangeCheckingMixin] r = FollowerUserFilterRule ( less_than = 100 , more_than = 1 ) # 2. Parse from configuration # using BaseModel.parse_obj() # https://pydantic-docs.helpmanual.io/usage/models/#helper-functions # # follower: # less_than: 100 # more_than: 1 # r = FollowerUserFilterRule . parse_obj ({ \"follower\" : { \"less_than\" : 100 , \"more_than\" : 1 }}) In the rule class developing we use quite a few features provided by pydantic . For the most part using pydantic speed-up our development, but it made the rule class has unknown behavior, and implementing some simple features on the rule class (such as adding _keyword class variable ) required more time reading the documentation and experimenting. Take it as a trade-off.","title":"Inheritance structure of one example rule class"},{"location":"development/custom-rules/#how-the-rule-instances-are-generated-from-the-plan-configuration","text":"Since the exact logic may change in the future, the description here does not involve specific implementation. The description will be given with the following plan configuration. 1 2 3 4 5 6 7 8 9 10 11 plans: - user_plan: Name #(3) from: - names: ['TwitterDev', 'TwitterAPI'] that: - follower: #(4) less_than: 10 - following: more_than: 100000000 do: - block: {} When the program starts, Python loads module rules.config_parser into the namespace, the function call written in the global environment in module rules.config_parser are executed, loads all the rule classes (all classes inherited FromConfig , in fact, including plan classes, etc.) in module rules recursively in runtime (simply import all classes in this module will cause circular dependency problem, while move importing to other upper modules looks awkward). Once the program takes the plan configuration (in Python dictionary type) from the full configuration, the program will recursively parse the plan configuration using the ConfigParser under the rules.config_parser module, converting it into a list of plan instances which contain rule instances. The ConfigParser matching configuration and rules with the help of inheritance chain of rule classes and _keyword class variables of each rule class. The first step is to parse the root of the plan configuration (Python dictionary) i.e. the plan class, which inherit from the Plan parent class, so we know that all Plan 's subclasses are candidates for this step (and it is hard-coded). Now assuming that the root of first plan configuration is \"user_plan\", we'll look for the subclass which _keyword 's value is exactly user_plan , and it turns out to be the UserPlan class (if no answer occur, the ConfigParser will raise an error). Now the ConfigParser knows that it should try to pass the configuration to UserPlan 's constructor. Inside UserPlan 's constructor, the ConfigParser is called again for parsing rules inside this plan instance. This time the ConfigParser is given UserSourceRule , UserFilterRule , UserActionRule as candidate transforming targets' parent classes, and the ConfigParser will again search for the same _keyword class variables. For example, UserFilterRule + _keyword:follower => FollowerUserFilterRule . Repeating step 3 and step 4, whole plan configuration dictionary is transformed into plan instances. Possible construction and parsing errors are caught and collected outside the ConfigParser invoking logic. If no errors occur during the whole parsing process, the program will start executing the plan, otherwise the program will exit and print these errors to notify the user to fix them.","title":"How the rule instances are generated from the plan configuration"},{"location":"development/security-policy/","text":"Security Policy # This page is used to show which versions of the tool are affected by which vulnerabilities. There are currently no vulnerabilities present. It is recommended to update this tool to the latest version each time you run it (it is much easier to update with the help of pipx ). Reporting a Vulnerability # Please submit vulnerability or abuse reports via issues . Responses and fixes for such issues will be prioritized over any other issues. If the submitter determines that the problem is serious and should not directly disclose the specifics in public, please email the specifics to current maintainer and create an issue without the specifics (I generally check my emails once a week, but the creation of an issue can be notified immediately). We apologize that we cannot give an exact expected fix time.","title":"Security policy"},{"location":"development/security-policy/#security-policy","text":"This page is used to show which versions of the tool are affected by which vulnerabilities. There are currently no vulnerabilities present. It is recommended to update this tool to the latest version each time you run it (it is much easier to update with the help of pipx ).","title":"Security Policy"},{"location":"development/security-policy/#reporting-a-vulnerability","text":"Please submit vulnerability or abuse reports via issues . Responses and fixes for such issues will be prioritized over any other issues. If the submitter determines that the problem is serious and should not directly disclose the specifics in public, please email the specifics to current maintainer and create an issue without the specifics (I generally check my emails once a week, but the creation of an issue can be notified immediately). We apologize that we cannot give an exact expected fix time.","title":"Reporting a Vulnerability"},{"location":"usage/commands/","text":"Commands # This page mainly lists the commands available for this tool and their usage, a simple tutorial about command line usage is also provided. Available commands # Start the tool # 1 puntgun fire The most important command, core function of the tool. Validate syntax of plan configuration file # 1 puntgun check plan It is always good to have a dry run before the actual run. Especially if you want to run this tool in an automated way. This command only checks if the plan configuration file can pass the validation and be successfully parsed without a parsing error, it cannot check if the values configured in the rule will cause Twitter API complaints. Generate example configuration files # 1 puntgun gen example This tool requires the help of a configuration file to run properly, but it is distributed and installed alone. Running this command after installation will generate: A sample global configuration file, to help you adjust the behavior of the tool to your flavor. A sample plan configuration file, to help you write your first execution plan. Follow the tool's lead to generate the secrets file # This tool also needs secret values registered externally on Twitter Developer Platform to enable it to work properly. Let the tool guides you to register necessary tokens, and leave them to the tool to safely keep them into encrypted secrets file for future use. Change password # 1 puntgun gen new-password Easy password change is a desirable feature, and you just need to provide the present password to change it. Since the key file is protected by a password, this command will regenerate the private key file. The old private key file will be added with a .bak suffix to prevent overwriting, so you'll still have the chance to reverse the change. Dump plaintext secrets # 1 puntgun gen plaintext-secrets If you have configured the secrets configuration file, you can use this command to export the secret values to a file in plaintext. Please protect the exported file yourself. Appendix: Simple tutorial about how to use the tool # This part is for users unfamiliar with the command line interface. If you want to use the command line interface to perform other operations not mentioned, please make use of the search engine with keyword \"your terminal(e.g. cmd, mac terminal) expected operation(switch directory)\". Assuming that you can run the puntgun in the terminal, that is, when you type puntgun and enter, you will see the terminal print out the logo with help information. 1 2 3 4 5 6 7 8 > puntgun Usage: puntgun [ OPTIONS ] COMMAND [ ARGS ] ... LOGO HERE Options: ... Commands: ... If the terminal responses an error like puntgun not found , you can search for that error (key concept: PATH environment variable ) to find the cause and resolve or reinstall the tool. This tool contains multi-level subcommands, and you can execute them like this: 1 2 3 4 # the tool # | subcommand: abbreviation of \"generate\" # v v secondary subcommand: generate example files puntgun gen example You can check the built-in help information by adding --help argument behind any command, the command will not be executed, instead the help information about this command will be printed out. 1 2 3 4 5 6 7 8 9 > puntgun gen example --help Usage: puntgun gen example [ OPTIONS ] Generate example configuration files. Options: -o, --output-path TEXT Path of generated files. [ default: /home/u/.puntgun ] -h, --help Show this message and exit. Note the Options section, which indicates the arguments that can be passed to this command. Arguments can provide additional information to the tool (e.g. -o ) or change the behavior of the tool (e.g. --help ). For passing information via arguments, type like this: 1 2 3 # \"-o\" is abbreviation of \"--output-path\", they are same, just pass one. # Change the directory where the tool will generate files puntgun gen example -o \"/path/you/want/to/generate/example/files\" I think knowledge above is enough for you to use this tool, if you need help or want the documentation to contain more content, please ask questions in the forum . Don't forget to search before asking to see if the question and answer you need already exist.","title":"Commands"},{"location":"usage/commands/#commands","text":"This page mainly lists the commands available for this tool and their usage, a simple tutorial about command line usage is also provided.","title":"Commands"},{"location":"usage/commands/#available-commands","text":"","title":"Available commands"},{"location":"usage/commands/#start-the-tool","text":"1 puntgun fire The most important command, core function of the tool.","title":"Start the tool"},{"location":"usage/commands/#validate-syntax-of-plan-configuration-file","text":"1 puntgun check plan It is always good to have a dry run before the actual run. Especially if you want to run this tool in an automated way. This command only checks if the plan configuration file can pass the validation and be successfully parsed without a parsing error, it cannot check if the values configured in the rule will cause Twitter API complaints.","title":"Validate syntax of plan configuration file"},{"location":"usage/commands/#generate-example-configuration-files","text":"1 puntgun gen example This tool requires the help of a configuration file to run properly, but it is distributed and installed alone. Running this command after installation will generate: A sample global configuration file, to help you adjust the behavior of the tool to your flavor. A sample plan configuration file, to help you write your first execution plan.","title":"Generate example configuration files"},{"location":"usage/commands/#follow-the-tools-lead-to-generate-the-secrets-file","text":"This tool also needs secret values registered externally on Twitter Developer Platform to enable it to work properly. Let the tool guides you to register necessary tokens, and leave them to the tool to safely keep them into encrypted secrets file for future use.","title":"Follow the tool's lead to generate the secrets file"},{"location":"usage/commands/#change-password","text":"1 puntgun gen new-password Easy password change is a desirable feature, and you just need to provide the present password to change it. Since the key file is protected by a password, this command will regenerate the private key file. The old private key file will be added with a .bak suffix to prevent overwriting, so you'll still have the chance to reverse the change.","title":"Change password"},{"location":"usage/commands/#dump-plaintext-secrets","text":"1 puntgun gen plaintext-secrets If you have configured the secrets configuration file, you can use this command to export the secret values to a file in plaintext. Please protect the exported file yourself.","title":"Dump plaintext secrets"},{"location":"usage/commands/#appendix-simple-tutorial-about-how-to-use-the-tool","text":"This part is for users unfamiliar with the command line interface. If you want to use the command line interface to perform other operations not mentioned, please make use of the search engine with keyword \"your terminal(e.g. cmd, mac terminal) expected operation(switch directory)\". Assuming that you can run the puntgun in the terminal, that is, when you type puntgun and enter, you will see the terminal print out the logo with help information. 1 2 3 4 5 6 7 8 > puntgun Usage: puntgun [ OPTIONS ] COMMAND [ ARGS ] ... LOGO HERE Options: ... Commands: ... If the terminal responses an error like puntgun not found , you can search for that error (key concept: PATH environment variable ) to find the cause and resolve or reinstall the tool. This tool contains multi-level subcommands, and you can execute them like this: 1 2 3 4 # the tool # | subcommand: abbreviation of \"generate\" # v v secondary subcommand: generate example files puntgun gen example You can check the built-in help information by adding --help argument behind any command, the command will not be executed, instead the help information about this command will be printed out. 1 2 3 4 5 6 7 8 9 > puntgun gen example --help Usage: puntgun gen example [ OPTIONS ] Generate example configuration files. Options: -o, --output-path TEXT Path of generated files. [ default: /home/u/.puntgun ] -h, --help Show this message and exit. Note the Options section, which indicates the arguments that can be passed to this command. Arguments can provide additional information to the tool (e.g. -o ) or change the behavior of the tool (e.g. --help ). For passing information via arguments, type like this: 1 2 3 # \"-o\" is abbreviation of \"--output-path\", they are same, just pass one. # Change the directory where the tool will generate files puntgun gen example -o \"/path/you/want/to/generate/example/files\" I think knowledge above is enough for you to use this tool, if you need help or want the documentation to contain more content, please ask questions in the forum . Don't forget to search before asking to see if the question and answer you need already exist.","title":"Appendix: Simple tutorial about how to use the tool"},{"location":"usage/report-file/","text":"Report File # Each run (with the fire command, particularly) of this tool will generate a corresponding report file for the user to check later or as a data source for another process. The content of the report file is in JSON format. Due to the strict format restriction of JSON itself, the content will only form the correct json format after the tool exits normally (including exit after unexpected error caught). If the tool exits abnormally the content will lack ]} as a complementary part, you can manually append ]} to report file end to correct the format. Report File Content # The report contains three parts: information about the tool, information about this run, and key events that occurred during the run. All fields are generated before the first plan starts running, except for the records field, which is continuously expanded at runtime. Field Example Description reference_documentation URL of this documentation JSON doesn't allow comments exist, so... tool_version \"0.1.0\" Current tool version, indicate what data structure this report is generate_time \"2022-01-01T00:00:00.000000\" Report generating time in ISO 8601 format at UTC+0 timezone plan_configuration [<plan config>,...] Plan configuration of this run plan_ids [<plan id>,...] See description below records [<record>,...] See description below 1 2 3 4 5 6 7 8 { \"reference_documentation\" : \"https://boholder.github.io/puntgun/dev//usage/report-file\" , \"tool_version\" : \"0.1.0\" , \"generate_time\" : \"2022-01-01T00:00:00.000000\" , \"plan_configuration\" : [], \"plan_ids\" : [], \"records\" : [] } Note If the tool exits normally, the last item of records is empty . It's a trade-off. JSON does not allow a comma to exist after the last item in the list, and the writing of the records file is delegated to the logger library (can not manually gain write access to report file and remove the extra comma). Plan Id # Relationship of plans and plan result records for de-redundancy purpose. The plans are numbered according to their order in the configuration, starting from zero. Records can indicate which plan it belonging to just with plan id. 1 2 3 4 { \"name\" : \"plan name\" , \"id\" : 0 } Record # The Record data is records of key events that occurred during the run. 1 2 3 4 5 6 { \"type\" : \"the event type of this record\" , \"data\" : { \"information_of_this_record\" : \"fields differ by event type\" } } User Plan Result # When a candidate triggers filter rule set and actions are performed, a plan result record is generated (only the action rule will actually make changes to the Twitter account, so candidates that do not trigger the filter rule will not be recorded). This record can be used to perform further operations, such as undo actions. Field in data Example Description plan_id 0 Indicate which plan it belonging to (see Plan Id ) target {...} Target user of action rules who triggered filter rule set target.id 2244994945 User id, integer target.username \"TwitterDev\" User handle decisive_filter_rule {...} Which filter rule this user triggered decisive_filter_rule.keyword \"following\" Triggered filter rule's keyword decisive_filter_rule.value \"less_than=100.0 more_than=1.0\" Triggered filter rule's configuration in plan (just for human reading, can't parse the origin rule from it) action_rule_results [<action rule result>,...] Execution result of each action rule action_rule_results[].keyword \"block\" One action rule's keyword action_rule_results[].value \"...\" One action rule's configuration action_rule_results[].done true Whether this action rule is successfully executed Example: User @TwitterDev who was blocked for triggering following count filter rule. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \"type\" : \"user_plan_result\" , \"data\" : { \"plan_id\" : 0 , \"target\" : { \"id\" : 2244994945 , \"username\" : \"TwitterDev\" }, \"decisive_filter_rule\" : { \"keyword\" : \"following\" , \"value\" : \"less_than=100.0 more_than=1.0\" }, \"action_rule_results\" : [ { \"keyword\" : \"block\" , \"value\" : \"\" , \"done\" : true } ] } } Twitter API Error # This type of error is raised when a Twitter Development API query returns success status (http status code is 200), but has an \"errors\" field in the response body, which indicates several \"Partial error\" occurs and the result only contains what Twitter server can figure out. This type of expected error does not cause the tool to exit. Check this Twitter official documentation for more details. We'll record these errors along with the invoked API and passed arguments, so we can reproduce the error for improving the tool's logic or feed another process with these errors for handling them. Field in data Example Description query_func_name \"get_users\" Which client function (Twitter API) is invoked query_params {...} All parameters passed to the function (to query API) errors [<api error>,...] Errors returned by the Twitter platform errors[].title \"Not Found Error\" The error type defined by Twitter errors[].ref_url \"https://...\" URL of Twitter documentation about this error errors[].detail \"...\" Human readable explanation about where is wrong errors[].parameter \"usernames\" In which parameter does the error exist errors[].value \"UsErNoTExIst4242\" The value that caused the error Example: Resource Not Found error is returned because we request information from Twitter about a user who does not exist. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \"type\" : \"twitter_api_errors\" , \"data\" : { \"query_func_name\" : \"get_users\" , \"query_params\" : { \"all_args_passed_to_the_client_function\" : \"too long to show here\" }, \"errors\" : [ { \"title\" : \"Not Found Error\" , \"ref_url\" : \"https://api.twitter.com/2/problems/resource-not-found\" , \"detail\" : \"Could not find user with usernames: [UsErNoTExIst4242].\" , \"parameter\" : \"usernames\" , \"value\" : \"UsErNoTExIst4242\" } ] } }","title":"Report File"},{"location":"usage/report-file/#report-file","text":"Each run (with the fire command, particularly) of this tool will generate a corresponding report file for the user to check later or as a data source for another process. The content of the report file is in JSON format. Due to the strict format restriction of JSON itself, the content will only form the correct json format after the tool exits normally (including exit after unexpected error caught). If the tool exits abnormally the content will lack ]} as a complementary part, you can manually append ]} to report file end to correct the format.","title":"Report File"},{"location":"usage/report-file/#report-file-content","text":"The report contains three parts: information about the tool, information about this run, and key events that occurred during the run. All fields are generated before the first plan starts running, except for the records field, which is continuously expanded at runtime. Field Example Description reference_documentation URL of this documentation JSON doesn't allow comments exist, so... tool_version \"0.1.0\" Current tool version, indicate what data structure this report is generate_time \"2022-01-01T00:00:00.000000\" Report generating time in ISO 8601 format at UTC+0 timezone plan_configuration [<plan config>,...] Plan configuration of this run plan_ids [<plan id>,...] See description below records [<record>,...] See description below 1 2 3 4 5 6 7 8 { \"reference_documentation\" : \"https://boholder.github.io/puntgun/dev//usage/report-file\" , \"tool_version\" : \"0.1.0\" , \"generate_time\" : \"2022-01-01T00:00:00.000000\" , \"plan_configuration\" : [], \"plan_ids\" : [], \"records\" : [] } Note If the tool exits normally, the last item of records is empty . It's a trade-off. JSON does not allow a comma to exist after the last item in the list, and the writing of the records file is delegated to the logger library (can not manually gain write access to report file and remove the extra comma).","title":"Report File Content"},{"location":"usage/report-file/#plan-id","text":"Relationship of plans and plan result records for de-redundancy purpose. The plans are numbered according to their order in the configuration, starting from zero. Records can indicate which plan it belonging to just with plan id. 1 2 3 4 { \"name\" : \"plan name\" , \"id\" : 0 }","title":"Plan Id"},{"location":"usage/report-file/#record","text":"The Record data is records of key events that occurred during the run. 1 2 3 4 5 6 { \"type\" : \"the event type of this record\" , \"data\" : { \"information_of_this_record\" : \"fields differ by event type\" } }","title":"Record"},{"location":"usage/report-file/#user-plan-result","text":"When a candidate triggers filter rule set and actions are performed, a plan result record is generated (only the action rule will actually make changes to the Twitter account, so candidates that do not trigger the filter rule will not be recorded). This record can be used to perform further operations, such as undo actions. Field in data Example Description plan_id 0 Indicate which plan it belonging to (see Plan Id ) target {...} Target user of action rules who triggered filter rule set target.id 2244994945 User id, integer target.username \"TwitterDev\" User handle decisive_filter_rule {...} Which filter rule this user triggered decisive_filter_rule.keyword \"following\" Triggered filter rule's keyword decisive_filter_rule.value \"less_than=100.0 more_than=1.0\" Triggered filter rule's configuration in plan (just for human reading, can't parse the origin rule from it) action_rule_results [<action rule result>,...] Execution result of each action rule action_rule_results[].keyword \"block\" One action rule's keyword action_rule_results[].value \"...\" One action rule's configuration action_rule_results[].done true Whether this action rule is successfully executed Example: User @TwitterDev who was blocked for triggering following count filter rule. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \"type\" : \"user_plan_result\" , \"data\" : { \"plan_id\" : 0 , \"target\" : { \"id\" : 2244994945 , \"username\" : \"TwitterDev\" }, \"decisive_filter_rule\" : { \"keyword\" : \"following\" , \"value\" : \"less_than=100.0 more_than=1.0\" }, \"action_rule_results\" : [ { \"keyword\" : \"block\" , \"value\" : \"\" , \"done\" : true } ] } }","title":"User Plan Result"},{"location":"usage/report-file/#twitter-api-error","text":"This type of error is raised when a Twitter Development API query returns success status (http status code is 200), but has an \"errors\" field in the response body, which indicates several \"Partial error\" occurs and the result only contains what Twitter server can figure out. This type of expected error does not cause the tool to exit. Check this Twitter official documentation for more details. We'll record these errors along with the invoked API and passed arguments, so we can reproduce the error for improving the tool's logic or feed another process with these errors for handling them. Field in data Example Description query_func_name \"get_users\" Which client function (Twitter API) is invoked query_params {...} All parameters passed to the function (to query API) errors [<api error>,...] Errors returned by the Twitter platform errors[].title \"Not Found Error\" The error type defined by Twitter errors[].ref_url \"https://...\" URL of Twitter documentation about this error errors[].detail \"...\" Human readable explanation about where is wrong errors[].parameter \"usernames\" In which parameter does the error exist errors[].value \"UsErNoTExIst4242\" The value that caused the error Example: Resource Not Found error is returned because we request information from Twitter about a user who does not exist. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \"type\" : \"twitter_api_errors\" , \"data\" : { \"query_func_name\" : \"get_users\" , \"query_params\" : { \"all_args_passed_to_the_client_function\" : \"too long to show here\" }, \"errors\" : [ { \"title\" : \"Not Found Error\" , \"ref_url\" : \"https://api.twitter.com/2/problems/resource-not-found\" , \"detail\" : \"Could not find user with usernames: [UsErNoTExIst4242].\" , \"parameter\" : \"usernames\" , \"value\" : \"UsErNoTExIst4242\" } ] } }","title":"Twitter API Error"}]}