import functools
import threading

import pytest


def experimental():
    """Decorator. Skip this test because it's for testing behaviors of libraries etc. for developing."""

    def decorator(func):
        @pytest.mark.skip(reason="experimental")
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)

        return wrapper

    return decorator


class UniqueTestFileNameGenerator(object):
    """
    In case of different test cases conflict with each other due to refer to same test file name
    in same batch of parallel running.
    It's ok if this class assigns already exists test files (generated by previous running) to them,
    because every test case will guarantee truncating and rewriting the file first.
    """

    @staticmethod
    @functools.lru_cache(maxsize=1)
    def singleton():
        """Get the singleton instance."""
        return UniqueTestFileNameGenerator()

    def __init__(self, value=0):
        self._value = int(value)
        self._lock = threading.Lock()

    def take_one(self, suffix=''):
        with self._lock:
            self._value += 1
            return f'test_{self._value}_file.{suffix}'


def take_one_unique_test_file_name(suffix=''):
    """In case of different test cases conflict with each other due to refer to same test file name."""
    return UniqueTestFileNameGenerator.singleton().take_one(suffix)
