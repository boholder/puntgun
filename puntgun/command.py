from pathlib import Path

from loguru import logger

import runner
import util
from client import Client
from conf import config, example
from conf.encrypto import load_or_generate_private_key
from conf.secret import load_or_request_all_secrets


def load_secrets_with_keyboard_interrupt_exit():
    try:
        return load_or_request_all_secrets(load_or_generate_private_key())
    except KeyboardInterrupt:
        logger.bind(o=True).info("The tool is stopped by the keyboard.")
        exit(1)


class Gen(object):
    """Generate various files by the tool."""

    @staticmethod
    def secrets(secrets_file=str(config.secrets_file),
                private_key_file=str(config.pri_key_file)):
        """
        Let the tool guides you to register necessary secrets and keep them for future use.
        :param secrets_file: Cipher text file which includes your encrypted secrets.
        :param private_key_file: Tool generated password protected private key for protecting your secrets.
        """
        config.reload_important_files(secrets_file=secrets_file,
                                      pri_key_file=private_key_file)
        load_secrets_with_keyboard_interrupt_exit()

    @staticmethod
    def plain_secrets(secrets_file=str(config.secrets_file),
                      # this path will only be used here, so we needn't add it to config module.
                      output_file=str(config.config_path.joinpath('.secrets_plaintext.yml'))):
        """
        Extract secrets from present secrets file and save them into a file in plaintext format.
        Please protect the generated file as carefully as ou would a password.
        :param secrets_file: File generated by the tool once you have started it before.
        :param output_file: In which you want to save plaintext secrets.
        """

        config.reload_important_files(secrets_file=secrets_file)
        secrets = load_secrets_with_keyboard_interrupt_exit()

        output_file = Path(output_file)
        util.backup_if_exists(output_file)
        with open(output_file, 'w', encoding='utf-8') as f:
            f.writelines(f'{key}: {value}\n' for key, value in secrets.items())

        logger.bind(o=True).info(f"Secrets are dumped: {output_file}")

    @staticmethod
    def config(output_path=str(config.config_path)):
        """
        Generate example configuration files: tool setting file and plan configuration file.
        :param output_path: path to output directory.
        """

        example_settings_file = Path(output_path).joinpath('example-settings.yml')
        util.backup_if_exists(example_settings_file)
        with open(example_settings_file, 'w', encoding='utf-8') as f:
            f.write(example.tool_settings)

        example_plan_file = Path(output_path).joinpath('example-plan.yml')
        util.backup_if_exists(example_plan_file)
        with open(example_plan_file, 'w', encoding='utf-8') as f:
            f.write(example.plan_config)

        logger.bind(o=True).info(f"""
Example configuration files generated:
settings: {example_settings_file}
plan: {example_plan_file}
""")


class Check(object):
    """Validate things like configuration files, check configuration syntax etc."""

    @staticmethod
    def plan(plan_file=str(config.plan_file)):
        """
        Validate plan configuration file's syntax.
        :param plan_file: Plan configuration file you'd like to check.
        """
        config.reload_important_files(plan_file=plan_file)
        runner.parse_plans_config(runner.get_and_validate_plan_config())


class Command(object):
    gen = Gen()
    check = Check()

    @staticmethod
    def fire(config_path=str(config.config_path),
             plan_file=str(config.plan_file),
             settings_file=str(config.settings_file),
             private_key_file=str(config.pri_key_file),
             secrets_file=str(config.secrets_file),
             report_file=str(config.report_file)):
        """
        Start processing base on given configuration files.
        :param config_path: Path of various configuration files the tool needs.
        :param plan_file: Plan configuration file you'd like to execute.
        :param settings_file: Global tool settings that will apply to every execution.
        :param private_key_file: Tool generated password protected private key.
        :param secrets_file: Tool generated cipher text file or user writen plain text file contains secrets.
        :param report_file: Expect path of the tool generated execution report.
        """
        logger.info("Run command [fire]")
        config.reload_important_files(config_path=config_path,
                                      plan_file=plan_file,
                                      settings_file=settings_file,
                                      pri_key_file=private_key_file,
                                      secrets_file=secrets_file,
                                      report_file=report_file)
        # only config log files, stderr logs... in this command.
        config.config_logging_options()

        try:
            # Warm up? Initialization?
            # Load secrets and create singleton client instance before parsing and executing plans.
            #
            # I found that after the reactivex pipeline (plan execution) is started,
            # user can't exit the program by pressing "Ctrl+C" easily.
            # And there is no "os._exit()" in os module if I want to exit in sub-thread:
            # https://stackoverflow.com/questions/1489669/how-to-exit-the-entire-application-from-a-python-thread
            Client.singleton()
            runner.start()
        except KeyboardInterrupt:
            logger.bind(o=True).info("The tool is stopped by the keyboard.")
            exit(1)
